/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 816
(module) {

/* Clusterize.js - v1.0.0 - 2023-01-22
 http://NeXTs.github.com/Clusterize.js/
 Copyright (c) 2015 Denis Lukov; Licensed MIT */

;(function(p,m){ true?module.exports=m():0})("Clusterize",function(){function p(b,a,c){return a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c)}function m(b,a,c){return a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c)}function t(b){return"[object Array]"===Object.prototype.toString.call(b)}function q(b,a){return window.getComputedStyle?window.getComputedStyle(a)[b]:
a.currentStyle[b]}var r=function(){for(var b=3,a=document.createElement("b"),c=a.all||[];a.innerHTML="\x3c!--[if gt IE "+ ++b+"]><i><![endif]--\x3e",c[0];);return 4<b?b:document.documentMode}(),C=navigator.platform.toLowerCase().indexOf("mac")+1,n=function(b){if(!(this instanceof n))return new n(b);var a=this,c={rows_in_block:50,blocks_in_cluster:4,tag:null,show_no_data_row:!0,no_data_class:"clusterize-no-data",no_data_text:"No data",keep_parity:!0,callbacks:{}};a.options={};for(var d="rows_in_block blocks_in_cluster show_no_data_row no_data_class no_data_text keep_parity tag callbacks".split(" "),
h=0,g;g=d[h];h++)a.options[g]="undefined"!=typeof b[g]&&null!=b[g]?b[g]:c[g];c=["scroll","content"];for(h=0;d=c[h];h++)if(a[d+"_elem"]=b[d+"Id"]?document.getElementById(b[d+"Id"]):b[d+"Elem"],!a[d+"_elem"])throw Error("Error! Could not find "+d+" element");a.content_elem.hasAttribute("tabindex")||a.content_elem.setAttribute("tabindex",0);var e=t(b.rows)?b.rows:a.fetchMarkup(),k={};b=a.scroll_elem.scrollTop;a.insertToDOM(e,k);a.scroll_elem.scrollTop=b;var l=!1,w=0,u=!1,x=function(){C&&(u||(a.content_elem.style.pointerEvents=
"none"),u=!0,clearTimeout(w),w=setTimeout(function(){a.content_elem.style.pointerEvents="auto";u=!1},50));l!=(l=a.getClusterNum(e))&&a.insertToDOM(e,k);a.options.callbacks.scrollingProgress&&a.options.callbacks.scrollingProgress(a.getScrollProgress())},y=0,z=function(){clearTimeout(y);y=setTimeout(a.refresh,100)};p("scroll",a.scroll_elem,x);p("resize",window,z);a.destroy=function(f){m("scroll",a.scroll_elem,x);m("resize",window,z);a.html((f?a.generateEmptyRow():e).join(""))};a.refresh=function(f){(a.getRowsHeight(e)||
f)&&a.update(e)};a.update=function(f){e=t(f)?f:[];f=a.scroll_elem.scrollTop;e.length*a.options.item_height<f&&(l=a.scroll_elem.scrollTop=0);a.insertToDOM(e,k);a.scroll_elem.scrollTop=f};a.clear=function(){a.update([])};a.getRowsAmount=function(){return e.length};a.getScrollProgress=function(){return this.options.scroll_top/(e.length*this.options.item_height)*100||0};var B=function(f,A){var v=t(A)?A:[];v.length&&(e="append"==f?e.concat(v):v.concat(e),a.insertToDOM(e,k))};a.append=function(f){B("append",
f)};a.prepend=function(f){B("prepend",f)}};n.prototype={constructor:n,fetchMarkup:function(){for(var b=[],a=this.getChildNodes(this.content_elem);a.length;)b.push(a.shift().outerHTML);return b},exploreEnvironment:function(b,a){var c=this.options;c.content_tag=this.content_elem.tagName.toLowerCase();b.length&&(r&&9>=r&&!c.tag&&(c.tag=b[0].match(/<([^>\s/]*)/)[1].toLowerCase()),1>=this.content_elem.children.length&&(a.data=this.html(b[0]+b[0]+b[0])),c.tag||(c.tag=this.content_elem.children[0].tagName.toLowerCase()),
this.getRowsHeight(b))},getRowsHeight:function(b){var a=this.options,c=a.item_height;a.cluster_height=0;if(b.length&&(b=this.content_elem.children,b.length)){var d=b[Math.floor(b.length/2)];a.item_height=d.offsetHeight;"tr"==a.tag&&"collapse"!=q("borderCollapse",this.content_elem)&&(a.item_height+=parseInt(q("borderSpacing",this.content_elem),10)||0);"tr"!=a.tag&&(b=parseInt(q("marginTop",d),10)||0,d=parseInt(q("marginBottom",d),10)||0,a.item_height+=Math.max(b,d));a.block_height=a.item_height*a.rows_in_block;
a.rows_in_cluster=a.blocks_in_cluster*a.rows_in_block;a.cluster_height=a.blocks_in_cluster*a.block_height;return c!=a.item_height}},getClusterNum:function(b){var a=this.options;a.scroll_top=this.scroll_elem.scrollTop;var c=a.cluster_height-a.block_height;return Math.min(Math.floor(a.scroll_top/c),Math.floor(b.length*a.item_height/c))},generateEmptyRow:function(){var b=this.options;if(!b.tag||!b.show_no_data_row)return[];var a=document.createElement(b.tag),c=document.createTextNode(b.no_data_text);
a.className=b.no_data_class;if("tr"==b.tag){var d=document.createElement("td");d.colSpan=100;d.appendChild(c)}a.appendChild(d||c);return[a.outerHTML]},generate:function(b){var a=this.options,c=b.length;if(c<a.rows_in_block)return{top_offset:0,bottom_offset:0,rows_above:0,rows:c?b:this.generateEmptyRow()};var d=Math.max((a.rows_in_cluster-a.rows_in_block)*this.getClusterNum(b),0),h=d+a.rows_in_cluster,g=Math.max(d*a.item_height,0);a=Math.max((c-h)*a.item_height,0);c=[];var e=d;for(1>g&&e++;d<h;d++)b[d]&&
c.push(b[d]);return{top_offset:g,bottom_offset:a,rows_above:e,rows:c}},renderExtraTag:function(b,a){var c=document.createElement(this.options.tag);c.className=["clusterize-extra-row","clusterize-"+b].join(" ");a&&(c.style.height=a+"px");return c.outerHTML},insertToDOM:function(b,a){this.options.cluster_height||this.exploreEnvironment(b,a);var c=this.generate(b),d=c.rows.join(""),h=this.checkChanges("data",d,a),g=this.checkChanges("top",c.top_offset,a),e=this.checkChanges("bottom",c.bottom_offset,
a),k=this.options.callbacks,l=[];h||g?(c.top_offset&&(this.options.keep_parity&&l.push(this.renderExtraTag("keep-parity")),l.push(this.renderExtraTag("top-space",c.top_offset))),l.push(d),c.bottom_offset&&l.push(this.renderExtraTag("bottom-space",c.bottom_offset)),k.clusterWillChange&&k.clusterWillChange(),this.html(l.join("")),"ol"==this.options.content_tag&&this.content_elem.setAttribute("start",c.rows_above),this.content_elem.style["counter-increment"]="clusterize-counter "+(c.rows_above-1),k.clusterChanged&&
k.clusterChanged()):e&&(this.content_elem.lastChild.style.height=c.bottom_offset+"px")},html:function(b){var a=this.content_elem;if(r&&9>=r&&"tr"==this.options.tag){var c=document.createElement("div");for(c.innerHTML="<table><tbody>"+b+"</tbody></table>";b=a.lastChild;)a.removeChild(b);for(c=this.getChildNodes(c.firstChild.firstChild);c.length;)a.appendChild(c.shift())}else a.innerHTML=b},getChildNodes:function(b){b=b.children;for(var a=[],c=0,d=b.length;c<d;c++)a.push(b[c]);return a},checkChanges:function(b,
a,c){var d=a!=c[b];c[b]=a;return d}};return n});

/***/ },

/***/ 563
(module) {

/**
 * lightgallery | 2.9.0 | October 1st 2025
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */

!function(e,l){ true?module.exports=l():0}(this,(function(){"use strict";var e=function(){return(e=Object.assign||function(e){for(var l,n=1,t=arguments.length;n<t;n++)for(var c in l=arguments[n])Object.prototype.hasOwnProperty.call(l,c)&&(e[c]=l[c]);return e}).apply(this,arguments)},l={fullScreen:!0,fullscreenPluginStrings:{toggleFullscreen:"Toggle Fullscreen"}};return function(){function n(n,t){return this.core=n,this.$LG=t,this.settings=e(e({},l),this.core.settings),this}return n.prototype.init=function(){var e="";if(this.settings.fullScreen){if(!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled))return;e='<button type="button" aria-label="'+this.settings.fullscreenPluginStrings.toggleFullscreen+'" class="lg-fullscreen lg-icon"></button>',this.core.$toolbar.append(e),this.fullScreen()}},n.prototype.isFullScreen=function(){return document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement},n.prototype.requestFullscreen=function(){var e=document.documentElement;e.requestFullscreen?e.requestFullscreen():e.msRequestFullscreen?e.msRequestFullscreen():e.mozRequestFullScreen?e.mozRequestFullScreen():e.webkitRequestFullscreen&&e.webkitRequestFullscreen()},n.prototype.exitFullscreen=function(){document.exitFullscreen?document.exitFullscreen():document.msExitFullscreen?document.msExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()},n.prototype.fullScreen=function(){var e=this;this.$LG(document).on("fullscreenchange.lg.global"+this.core.lgId+" \n            webkitfullscreenchange.lg.global"+this.core.lgId+" \n            mozfullscreenchange.lg.global"+this.core.lgId+" \n            MSFullscreenChange.lg.global"+this.core.lgId,(function(){e.core.lgOpened&&e.core.outer.toggleClass("lg-fullscreen-on")})),this.core.outer.find(".lg-fullscreen").first().on("click.lg",(function(){e.isFullScreen()?e.exitFullscreen():e.requestFullscreen()}))},n.prototype.closeGallery=function(){this.isFullScreen()&&this.exitFullscreen()},n.prototype.destroy=function(){this.$LG(document).off("fullscreenchange.lg.global"+this.core.lgId+" \n            webkitfullscreenchange.lg.global"+this.core.lgId+" \n            mozfullscreenchange.lg.global"+this.core.lgId+" \n            MSFullscreenChange.lg.global"+this.core.lgId)},n}()}));

/***/ },

/***/ 569
(module) {

/**
 * lightgallery | 2.8.3 | March 1st 2025
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */

!function(e,t){ true?module.exports=t():0}(this,(function(){"use strict";var e=function(){return(e=Object.assign||function(e){for(var t,o=1,i=arguments.length;o<i;o++)for(var s in t=arguments[o])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)},t={scale:1,zoom:!0,infiniteZoom:!0,actualSize:!0,showZoomInOutIcons:!1,actualSizeIcons:{zoomIn:"lg-zoom-in",zoomOut:"lg-zoom-out"},enableZoomAfter:300,zoomPluginStrings:{zoomIn:"Zoom in",zoomOut:"Zoom out",viewActualSize:"View actual size"}},o="lgContainerResize",i="lgBeforeOpen",s="lgAfterOpen",a="lgSlideItemLoad",n="lgAfterSlide",r="lgRotateLeft",l="lgRotateRight",c="lgFlipHorizontal",g="lgFlipVertical";return function(){function h(o,i){return this.core=o,this.$LG=i,this.settings=e(e({},t),this.core.settings),this}return h.prototype.buildTemplates=function(){var e=this.settings.showZoomInOutIcons?'<button id="'+this.core.getIdName("lg-zoom-in")+'" type="button" aria-label="'+this.settings.zoomPluginStrings.zoomIn+'" class="lg-zoom-in lg-icon"></button><button id="'+this.core.getIdName("lg-zoom-out")+'" type="button" aria-label="'+this.settings.zoomPluginStrings.zoomOut+'" class="lg-zoom-out lg-icon"></button>':"";this.settings.actualSize&&(e+='<button id="'+this.core.getIdName("lg-actual-size")+'" type="button" aria-label="'+this.settings.zoomPluginStrings.viewActualSize+'" class="'+this.settings.actualSizeIcons.zoomIn+' lg-icon"></button>'),this.core.outer.addClass("lg-use-transition-for-zoom"),this.core.$toolbar.first().append(e)},h.prototype.enableZoom=function(e){var t=this,o=this.settings.enableZoomAfter+e.detail.delay;this.$LG("body").first().hasClass("lg-from-hash")&&e.detail.delay?o=0:this.$LG("body").first().removeClass("lg-from-hash"),this.zoomableTimeout=setTimeout((function(){t.isImageSlide(t.core.index)&&(t.core.getSlideItem(e.detail.index).addClass("lg-zoomable"),e.detail.index===t.core.index&&t.setZoomEssentials())}),o+30)},h.prototype.enableZoomOnSlideItemLoad=function(){this.core.LGel.on(a+".zoom",this.enableZoom.bind(this))},h.prototype.getDragCords=function(e){return{x:e.pageX,y:e.pageY}},h.prototype.getSwipeCords=function(e){return{x:e.touches[0].pageX,y:e.touches[0].pageY}},h.prototype.getDragAllowedAxises=function(e,t){if(!this.containerRect)return{allowX:!1,allowY:!1};var o=this.core.getSlideItem(this.core.index).find(".lg-image").first().get(),i=0,s=0,a=o.getBoundingClientRect();e?(i=o.offsetHeight*e,s=o.offsetWidth*e):t?(i=a.height+t*a.height,s=a.width+t*a.width):(i=a.height,s=a.width);var n=i>this.containerRect.height;return{allowX:s>this.containerRect.width,allowY:n}},h.prototype.setZoomEssentials=function(){this.containerRect=this.core.$content.get().getBoundingClientRect()},h.prototype.zoomImage=function(e,t,o,i){if(!(Math.abs(t)<=0)){var s,a,n=this.containerRect.width/2+this.containerRect.left,r=this.containerRect.height/2+this.containerRect.top+this.scrollTop;1===e&&(this.positionChanged=!1);var l=this.getDragAllowedAxises(0,t),c=l.allowY,g=l.allowX;this.positionChanged&&(s=this.left/(this.scale-t),a=this.top/(this.scale-t),this.pageX=n-s,this.pageY=r-a,this.positionChanged=!1);var h,m,u=this.getPossibleSwipeDragCords(t),d=n-this.pageX,f=r-this.pageY;if(e-t>1){var p=(e-t)/Math.abs(t);h=(d=(t<0?-d:d)+this.left*(p+(t<0?-1:1)))/p,m=(f=(t<0?-f:f)+this.top*(p+(t<0?-1:1)))/p}else{h=d*(p=(e-t)*t),m=f*p}o&&(g?this.isBeyondPossibleLeft(h,u.minX)?h=u.minX:this.isBeyondPossibleRight(h,u.maxX)&&(h=u.maxX):e>1&&(h<u.minX?h=u.minX:h>u.maxX&&(h=u.maxX)),c?this.isBeyondPossibleTop(m,u.minY)?m=u.minY:this.isBeyondPossibleBottom(m,u.maxY)&&(m=u.maxY):e>1&&(m<u.minY?m=u.minY:m>u.maxY&&(m=u.maxY))),this.setZoomStyles({x:h,y:m,scale:e}),this.left=h,this.top=m,i&&this.setZoomImageSize()}},h.prototype.resetImageTranslate=function(e){if(this.isImageSlide(e)){var t=this.core.getSlideItem(e).find(".lg-image").first();this.imageReset=!1,t.removeClass("reset-transition reset-transition-y reset-transition-x"),this.core.outer.removeClass("lg-actual-size"),t.css("width","auto").css("height","auto"),setTimeout((function(){t.removeClass("no-transition")}),10)}},h.prototype.setZoomImageSize=function(){var e=this,t=this.core.getSlideItem(this.core.index).find(".lg-image").first();setTimeout((function(){var o=e.getCurrentImageActualSizeScale();e.scale>=o&&(t.addClass("no-transition"),e.imageReset=!0)}),500),setTimeout((function(){var o=e.getCurrentImageActualSizeScale();if(e.scale>=o){var i=e.getDragAllowedAxises(e.scale);t.css("width",t.get().naturalWidth+"px").css("height",t.get().naturalHeight+"px"),e.core.outer.addClass("lg-actual-size"),i.allowX&&i.allowY?t.addClass("reset-transition"):i.allowX&&!i.allowY?t.addClass("reset-transition-x"):!i.allowX&&i.allowY&&t.addClass("reset-transition-y")}}),550)},h.prototype.setZoomStyles=function(e){var t=this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first(),o=this.core.getSlideItem(this.core.index).find(".lg-image").first(),i=this.core.outer.find(".lg-current .lg-dummy-img").first();this.scale=e.scale,o.css("transform","scale3d("+e.scale+", "+e.scale+", 1)"),i.css("transform","scale3d("+e.scale+", "+e.scale+", 1)");var s="translate3d("+e.x+"px, "+e.y+"px, 0)";t.css("transform",s)},h.prototype.setActualSize=function(e,t){var o=this;if(!this.zoomInProgress){this.zoomInProgress=!0;var i=this.core.galleryItems[this.core.index];this.resetImageTranslate(e),setTimeout((function(){if(i.src&&!o.core.outer.hasClass("lg-first-slide-loading")){var e=o.getCurrentImageActualSizeScale(),s=o.scale;o.core.outer.hasClass("lg-zoomed")?o.scale=1:o.scale=o.getScale(e),o.setPageCords(t),o.beginZoom(o.scale),o.zoomImage(o.scale,o.scale-s,!0,!0)}}),50),setTimeout((function(){o.core.outer.removeClass("lg-grabbing").addClass("lg-grab")}),60),setTimeout((function(){o.zoomInProgress=!1}),610)}},h.prototype.getNaturalWidth=function(e){var t=this.core.getSlideItem(e).find(".lg-image").first(),o=this.core.galleryItems[e].width;return o?parseFloat(o):t.get().naturalWidth},h.prototype.getActualSizeScale=function(e,t){return e>=t?e/t||2:1},h.prototype.getCurrentImageActualSizeScale=function(){var e=this.core.getSlideItem(this.core.index).find(".lg-image").first().get().offsetWidth,t=this.getNaturalWidth(this.core.index)||e;return this.getActualSizeScale(t,e)},h.prototype.getPageCords=function(e){var t={};if(e)t.x=e.pageX||e.touches[0].pageX,t.y=e.pageY||e.touches[0].pageY;else{var o=this.core.$content.get().getBoundingClientRect();t.x=o.width/2+o.left,t.y=o.height/2+this.scrollTop+o.top}return t},h.prototype.setPageCords=function(e){var t=this.getPageCords(e);this.pageX=t.x,this.pageY=t.y},h.prototype.manageActualPixelClassNames=function(){this.core.getElementById("lg-actual-size").removeClass(this.settings.actualSizeIcons.zoomIn).addClass(this.settings.actualSizeIcons.zoomOut)},h.prototype.beginZoom=function(e){return this.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"),e>1?(this.core.outer.addClass("lg-zoomed"),this.manageActualPixelClassNames()):this.resetZoom(),e>1},h.prototype.getScale=function(e){var t=this.getCurrentImageActualSizeScale();return e<1?e=1:e>t&&(e=t),e},h.prototype.init=function(){var e=this;if(this.settings.zoom){this.buildTemplates(),this.enableZoomOnSlideItemLoad();var t=null;this.core.outer.on("dblclick.lg",(function(t){e.$LG(t.target).hasClass("lg-image")&&e.setActualSize(e.core.index,t)})),this.core.outer.on("touchstart.lg",(function(o){var i=e.$LG(o.target);1===o.touches.length&&i.hasClass("lg-image")&&(t?(clearTimeout(t),t=null,o.preventDefault(),e.setActualSize(e.core.index,o)):t=setTimeout((function(){t=null}),300))})),this.core.LGel.on(o+".zoom "+l+".zoom "+r+".zoom "+c+".zoom "+g+".zoom",(function(){if(e.core.lgOpened&&e.isImageSlide(e.core.index)&&!e.core.touchAction){var t=e.core.getSlideItem(e.core.index).find(".lg-img-wrap").first();e.top=0,e.left=0,e.setZoomEssentials(),e.setZoomSwipeStyles(t,{x:0,y:0}),e.positionChanged=!0}})),this.$LG(window).on("scroll.lg.zoom.global"+this.core.lgId,(function(){e.core.lgOpened&&(e.scrollTop=e.$LG(window).scrollTop())})),this.core.getElementById("lg-zoom-out").on("click.lg",(function(){if(e.isImageSlide(e.core.index)){var t=0;e.imageReset&&(e.resetImageTranslate(e.core.index),t=50),setTimeout((function(){var t=e.scale-e.settings.scale;t<1&&(t=1),e.beginZoom(t),e.zoomImage(t,-e.settings.scale,!0,!e.settings.infiniteZoom)}),t)}})),this.core.getElementById("lg-zoom-in").on("click.lg",(function(){e.zoomIn()})),this.core.getElementById("lg-actual-size").on("click.lg",(function(){e.setActualSize(e.core.index)})),this.core.LGel.on(i+".zoom",(function(){e.core.outer.find(".lg-item").removeClass("lg-zoomable")})),this.core.LGel.on(s+".zoom",(function(){e.scrollTop=e.$LG(window).scrollTop(),e.pageX=e.core.outer.width()/2,e.pageY=e.core.outer.height()/2+e.scrollTop,e.scale=1})),this.core.LGel.on(n+".zoom",(function(t){var o=t.detail.prevIndex;e.scale=1,e.positionChanged=!1,e.zoomInProgress=!1,e.resetZoom(o),e.resetImageTranslate(o),e.isImageSlide(e.core.index)&&e.setZoomEssentials()})),this.zoomDrag(),this.pinchZoom(),this.zoomSwipe(),this.zoomableTimeout=!1,this.positionChanged=!1,this.zoomInProgress=!1}},h.prototype.zoomIn=function(){if(this.isImageSlide(this.core.index)){var e=this.scale+this.settings.scale;this.settings.infiniteZoom||(e=this.getScale(e)),this.beginZoom(e),this.zoomImage(e,Math.min(this.settings.scale,e-this.scale),!0,!this.settings.infiniteZoom)}},h.prototype.resetZoom=function(e){this.core.outer.removeClass("lg-zoomed lg-zoom-drag-transition");var t=this.core.getElementById("lg-actual-size"),o=this.core.getSlideItem(void 0!==e?e:this.core.index);t.removeClass(this.settings.actualSizeIcons.zoomOut).addClass(this.settings.actualSizeIcons.zoomIn),o.find(".lg-img-wrap").first().removeAttr("style"),o.find(".lg-image").first().removeAttr("style"),this.scale=1,this.left=0,this.top=0,this.setPageCords()},h.prototype.getTouchDistance=function(e){return Math.sqrt((e.touches[0].pageX-e.touches[1].pageX)*(e.touches[0].pageX-e.touches[1].pageX)+(e.touches[0].pageY-e.touches[1].pageY)*(e.touches[0].pageY-e.touches[1].pageY))},h.prototype.pinchZoom=function(){var e=this,t=0,o=!1,i=1,s=0,a=this.core.getSlideItem(this.core.index);this.core.outer.on("touchstart.lg",(function(o){if(a=e.core.getSlideItem(e.core.index),e.isImageSlide(e.core.index)&&2===o.touches.length){if(o.preventDefault(),e.core.outer.hasClass("lg-first-slide-loading"))return;i=e.scale||1,e.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"),e.setPageCords(o),e.resetImageTranslate(e.core.index),e.core.touchAction="pinch",t=e.getTouchDistance(o)}})),this.core.$inner.on("touchmove.lg",(function(n){if(2===n.touches.length&&"pinch"===e.core.touchAction&&(e.$LG(n.target).hasClass("lg-item")||a.get().contains(n.target))){n.preventDefault();var r=e.getTouchDistance(n),l=t-r;if(!o&&Math.abs(l)>5&&(o=!0),o){s=e.scale;var c=Math.max(1,i+.02*-l);e.scale=Math.round(100*(c+Number.EPSILON))/100;var g=e.scale-s;e.zoomImage(e.scale,Math.round(100*(g+Number.EPSILON))/100,!1,!1)}}})),this.core.$inner.on("touchend.lg",(function(i){if("pinch"===e.core.touchAction&&(e.$LG(i.target).hasClass("lg-item")||a.get().contains(i.target))){if(o=!1,t=0,e.scale<=1)e.resetZoom();else{var s=e.getCurrentImageActualSizeScale();if(e.scale>=s){var n=s-e.scale;0===n&&(n=.01),e.zoomImage(s,n,!1,!0)}e.manageActualPixelClassNames(),e.core.outer.addClass("lg-zoomed")}e.core.touchAction=void 0}}))},h.prototype.touchendZoom=function(e,t,o,i,s){var a=t.x-e.x,n=t.y-e.y,r=Math.abs(a)/s+1,l=Math.abs(n)/s+1;r>2&&(r+=1),l>2&&(l+=1),a*=r,n*=l;var c=this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first(),g={};g.x=this.left+a,g.y=this.top+n;var h=this.getPossibleSwipeDragCords();(Math.abs(a)>15||Math.abs(n)>15)&&(i&&(this.isBeyondPossibleTop(g.y,h.minY)?g.y=h.minY:this.isBeyondPossibleBottom(g.y,h.maxY)&&(g.y=h.maxY)),o&&(this.isBeyondPossibleLeft(g.x,h.minX)?g.x=h.minX:this.isBeyondPossibleRight(g.x,h.maxX)&&(g.x=h.maxX)),i?this.top=g.y:g.y=this.top,o?this.left=g.x:g.x=this.left,this.setZoomSwipeStyles(c,g),this.positionChanged=!0)},h.prototype.getZoomSwipeCords=function(e,t,o,i,s){var a={};if(i){if(a.y=this.top+(t.y-e.y),this.isBeyondPossibleTop(a.y,s.minY)){var n=s.minY-a.y;a.y=s.minY-n/6}else if(this.isBeyondPossibleBottom(a.y,s.maxY)){var r=a.y-s.maxY;a.y=s.maxY+r/6}}else a.y=this.top;if(o){if(a.x=this.left+(t.x-e.x),this.isBeyondPossibleLeft(a.x,s.minX)){var l=s.minX-a.x;a.x=s.minX-l/6}else if(this.isBeyondPossibleRight(a.x,s.maxX)){var c=a.x-s.maxX;a.x=s.maxX+c/6}}else a.x=this.left;return a},h.prototype.isBeyondPossibleLeft=function(e,t){return e>=t},h.prototype.isBeyondPossibleRight=function(e,t){return e<=t},h.prototype.isBeyondPossibleTop=function(e,t){return e>=t},h.prototype.isBeyondPossibleBottom=function(e,t){return e<=t},h.prototype.isImageSlide=function(e){var t=this.core.galleryItems[e];return"image"===this.core.getSlideType(t)},h.prototype.getPossibleSwipeDragCords=function(e){var t=this.core.getSlideItem(this.core.index).find(".lg-image").first(),o=this.core.mediaContainerPosition.bottom,i=t.get().getBoundingClientRect(),s=i.height,a=i.width;return e&&(s+=e*s,a+=e*a),{minY:(s-this.containerRect.height)/2,maxY:(this.containerRect.height-s)/2+o,minX:(a-this.containerRect.width)/2,maxX:(this.containerRect.width-a)/2}},h.prototype.setZoomSwipeStyles=function(e,t){e.css("transform","translate3d("+t.x+"px, "+t.y+"px, 0)")},h.prototype.zoomSwipe=function(){var e,t,o=this,i={},s={},a=!1,n=!1,r=!1,l=new Date,c=(new Date,this.core.getSlideItem(this.core.index));this.core.$inner.on("touchstart.lg",(function(s){if(o.isImageSlide(o.core.index)&&(c=o.core.getSlideItem(o.core.index),(o.$LG(s.target).hasClass("lg-item")||c.get().contains(s.target))&&1===s.touches.length&&o.core.outer.hasClass("lg-zoomed"))){s.preventDefault(),l=new Date,o.core.touchAction="zoomSwipe",t=o.core.getSlideItem(o.core.index).find(".lg-img-wrap").first();var a=o.getDragAllowedAxises(0);r=a.allowY,((n=a.allowX)||r)&&(i=o.getSwipeCords(s)),e=o.getPossibleSwipeDragCords(),o.core.outer.addClass("lg-zoom-dragging lg-zoom-drag-transition")}})),this.core.$inner.on("touchmove.lg",(function(l){if(1===l.touches.length&&"zoomSwipe"===o.core.touchAction&&(o.$LG(l.target).hasClass("lg-item")||c.get().contains(l.target))){l.preventDefault(),o.core.touchAction="zoomSwipe",s=o.getSwipeCords(l);var g=o.getZoomSwipeCords(i,s,n,r,e);(Math.abs(s.x-i.x)>15||Math.abs(s.y-i.y)>15)&&(a=!0,o.setZoomSwipeStyles(t,g))}})),this.core.$inner.on("touchend.lg",(function(e){if("zoomSwipe"===o.core.touchAction&&(o.$LG(e.target).hasClass("lg-item")||c.get().contains(e.target))){if(e.preventDefault(),o.core.touchAction=void 0,o.core.outer.removeClass("lg-zoom-dragging"),!a)return;a=!1;var t=(new Date).valueOf()-l.valueOf();o.touchendZoom(i,s,n,r,t)}}))},h.prototype.zoomDrag=function(){var e,t,o,i,s=this,a={},n={},r=!1,l=!1,c=!1,g=!1;this.core.outer.on("mousedown.lg.zoom",(function(t){if(s.isImageSlide(s.core.index)){var n=s.core.getSlideItem(s.core.index);if(s.$LG(t.target).hasClass("lg-item")||n.get().contains(t.target)){e=new Date,i=s.core.getSlideItem(s.core.index).find(".lg-img-wrap").first();var l=s.getDragAllowedAxises(0);g=l.allowY,c=l.allowX,s.core.outer.hasClass("lg-zoomed")&&s.$LG(t.target).hasClass("lg-object")&&(c||g)&&(t.preventDefault(),a=s.getDragCords(t),o=s.getPossibleSwipeDragCords(),r=!0,s.core.outer.removeClass("lg-grab").addClass("lg-grabbing lg-zoom-drag-transition lg-zoom-dragging"))}}})),this.$LG(window).on("mousemove.lg.zoom.global"+this.core.lgId,(function(e){if(r){l=!0,n=s.getDragCords(e);var t=s.getZoomSwipeCords(a,n,c,g,o);s.setZoomSwipeStyles(i,t)}})),this.$LG(window).on("mouseup.lg.zoom.global"+this.core.lgId,(function(o){if(r){if(t=new Date,r=!1,s.core.outer.removeClass("lg-zoom-dragging"),l&&(a.x!==n.x||a.y!==n.y)){n=s.getDragCords(o);var i=t.valueOf()-e.valueOf();s.touchendZoom(a,n,c,g,i)}l=!1}s.core.outer.removeClass("lg-grabbing").addClass("lg-grab")}))},h.prototype.closeGallery=function(){this.resetZoom(),this.zoomInProgress=!1},h.prototype.destroy=function(){this.$LG(window).off(".lg.zoom.global"+this.core.lgId),this.core.LGel.off(".lg.zoom"),this.core.LGel.off(".zoom"),clearTimeout(this.zoomableTimeout),this.zoomableTimeout=!1},h}()}));


/***/ },

/***/ 360
(module) {

/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/lightgallery@2.8.3/lightgallery.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * lightgallery | 2.8.3 | March 1st 2025
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
!function(t,e){ true?module.exports=e():0}(this,(function(){"use strict";
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */var t=function(){return t=Object.assign||function(t){for(var e,i=1,s=arguments.length;i<s;i++)for(var n in e=arguments[i])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t},t.apply(this,arguments)};var e="lgAfterAppendSlide",i="lgInit",s="lgHasVideo",n="lgContainerResize",o="lgUpdateSlides",r="lgAfterAppendSubHtml",l="lgBeforeOpen",a="lgAfterOpen",d="lgSlideItemLoad",g="lgBeforeSlide",h="lgAfterSlide",c="lgPosterClick",u="lgDragStart",m="lgDragMove",p="lgDragEnd",f="lgBeforeNextSlide",y="lgBeforePrevSlide",v="lgBeforeClose",b="lgAfterClose",C={mode:"lg-slide",easing:"ease",speed:400,licenseKey:"0000-0000-000-0000",height:"100%",width:"100%",addClass:"",startClass:"lg-start-zoom",backdropDuration:300,container:"",startAnimationDuration:400,zoomFromOrigin:!0,hideBarsDelay:0,showBarsAfter:1e4,slideDelay:0,supportLegacyBrowser:!0,allowMediaOverlap:!1,videoMaxSize:"1280-720",loadYouTubePoster:!0,defaultCaptionHeight:0,ariaLabelledby:"",ariaDescribedby:"",resetScrollPosition:!0,hideScrollbar:!1,closable:!0,swipeToClose:!0,closeOnTap:!0,showCloseIcon:!0,showMaximizeIcon:!1,loop:!0,escKey:!0,keyPress:!0,trapFocus:!0,controls:!0,slideEndAnimation:!0,hideControlOnEnd:!1,mousewheel:!1,getCaptionFromTitleOrAlt:!0,appendSubHtmlTo:".lg-sub-html",subHtmlSelectorRelative:!1,preload:2,numberOfSlideItemsInDom:10,selector:"",selectWithin:"",nextHtml:"",prevHtml:"",index:0,iframeWidth:"100%",iframeHeight:"100%",iframeMaxWidth:"100%",iframeMaxHeight:"100%",download:!0,counter:!0,appendCounterTo:".lg-toolbar",swipeThreshold:50,enableSwipe:!0,enableDrag:!0,dynamic:!1,dynamicEl:[],extraProps:[],exThumbImage:"",isMobile:void 0,mobileSettings:{controls:!1,showCloseIcon:!1,download:!1},plugins:[],strings:{closeGallery:"Close gallery",toggleMaximize:"Toggle maximize",previousSlide:"Previous slide",nextSlide:"Next slide",download:"Download",playVideo:"Play video",mediaLoadingFailed:"Oops... Failed to load content..."}};var I=function(){function t(t){return this.cssVenderPrefixes=["TransitionDuration","TransitionTimingFunction","Transform","Transition"],this.selector=this._getSelector(t),this.firstElement=this._getFirstEl(),this}return t.generateUUID=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(t){var e=16*Math.random()|0;return("x"==t?e:3&e|8).toString(16)}))},t.prototype._getSelector=function(t,e){return void 0===e&&(e=document),"string"!=typeof t?t:(e=e||document,"#"===t.substring(0,1)?e.querySelector(t):e.querySelectorAll(t))},t.prototype._each=function(t){return this.selector?(void 0!==this.selector.length?[].forEach.call(this.selector,t):t(this.selector,0),this):this},t.prototype._setCssVendorPrefix=function(t,e,i){var s=e.replace(/-([a-z])/gi,(function(t,e){return e.toUpperCase()}));-1!==this.cssVenderPrefixes.indexOf(s)?(t.style[s.charAt(0).toLowerCase()+s.slice(1)]=i,t.style["webkit"+s]=i,t.style["moz"+s]=i,t.style["ms"+s]=i,t.style["o"+s]=i):t.style[s]=i},t.prototype._getFirstEl=function(){return this.selector&&void 0!==this.selector.length?this.selector[0]:this.selector},t.prototype.isEventMatched=function(t,e){var i=e.split(".");return t.split(".").filter((function(t){return t})).every((function(t){return-1!==i.indexOf(t)}))},t.prototype.attr=function(t,e){return void 0===e?this.firstElement?this.firstElement.getAttribute(t):"":(this._each((function(i){i.setAttribute(t,e)})),this)},t.prototype.find=function(t){return x(this._getSelector(t,this.selector))},t.prototype.first=function(){return this.selector&&void 0!==this.selector.length?x(this.selector[0]):x(this.selector)},t.prototype.eq=function(t){return x(this.selector[t])},t.prototype.parent=function(){return x(this.selector.parentElement)},t.prototype.get=function(){return this._getFirstEl()},t.prototype.removeAttr=function(t){var e=t.split(" ");return this._each((function(t){e.forEach((function(e){return t.removeAttribute(e)}))})),this},t.prototype.wrap=function(t){if(!this.firstElement)return this;var e=document.createElement("div");return e.className=t,this.firstElement.parentNode.insertBefore(e,this.firstElement),this.firstElement.parentNode.removeChild(this.firstElement),e.appendChild(this.firstElement),this},t.prototype.addClass=function(t){return void 0===t&&(t=""),this._each((function(e){t.split(" ").forEach((function(t){t&&e.classList.add(t)}))})),this},t.prototype.removeClass=function(t){return this._each((function(e){t.split(" ").forEach((function(t){t&&e.classList.remove(t)}))})),this},t.prototype.hasClass=function(t){return!!this.firstElement&&this.firstElement.classList.contains(t)},t.prototype.hasAttribute=function(t){return!!this.firstElement&&this.firstElement.hasAttribute(t)},t.prototype.toggleClass=function(t){return this.firstElement?(this.hasClass(t)?this.removeClass(t):this.addClass(t),this):this},t.prototype.css=function(t,e){var i=this;return this._each((function(s){i._setCssVendorPrefix(s,t,e)})),this},t.prototype.on=function(e,i){var s=this;return this.selector?(e.split(" ").forEach((function(e){Array.isArray(t.eventListeners[e])||(t.eventListeners[e]=[]),t.eventListeners[e].push(i),s.selector.addEventListener(e.split(".")[0],i)})),this):this},t.prototype.once=function(t,e){var i=this;return this.on(t,(function(){i.off(t),e(t)})),this},t.prototype.off=function(e){var i=this;return this.selector?(Object.keys(t.eventListeners).forEach((function(s){i.isEventMatched(e,s)&&(t.eventListeners[s].forEach((function(t){i.selector.removeEventListener(s.split(".")[0],t)})),t.eventListeners[s]=[])})),this):this},t.prototype.trigger=function(t,e){if(!this.firstElement)return this;var i=new CustomEvent(t.split(".")[0],{detail:e||null});return this.firstElement.dispatchEvent(i),this},t.prototype.load=function(t){var e=this;return fetch(t).then((function(t){return t.text()})).then((function(t){e.selector.innerHTML=t})),this},t.prototype.html=function(t){return void 0===t?this.firstElement?this.firstElement.innerHTML:"":(this._each((function(e){e.innerHTML=t})),this)},t.prototype.append=function(t){return this._each((function(e){"string"==typeof t?e.insertAdjacentHTML("beforeend",t):e.appendChild(t)})),this},t.prototype.prepend=function(t){return this._each((function(e){"string"==typeof t?e.insertAdjacentHTML("afterbegin",t):t instanceof HTMLElement&&e.insertBefore(t.cloneNode(!0),e.firstChild)})),this},t.prototype.remove=function(){return this._each((function(t){t.parentNode.removeChild(t)})),this},t.prototype.empty=function(){return this._each((function(t){t.innerHTML=""})),this},t.prototype.scrollTop=function(t){return void 0!==t?(document.body.scrollTop=t,document.documentElement.scrollTop=t,this):window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0},t.prototype.scrollLeft=function(t){return void 0!==t?(document.body.scrollLeft=t,document.documentElement.scrollLeft=t,this):window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0},t.prototype.offset=function(){if(!this.firstElement)return{left:0,top:0};var t=this.firstElement.getBoundingClientRect(),e=x("body").style().marginLeft;return{left:t.left-parseFloat(e)+this.scrollLeft(),top:t.top+this.scrollTop()}},t.prototype.style=function(){return this.firstElement?this.firstElement.currentStyle||window.getComputedStyle(this.firstElement):{}},t.prototype.width=function(){var t=this.style();return this.firstElement.clientWidth-parseFloat(t.paddingLeft)-parseFloat(t.paddingRight)},t.prototype.height=function(){var t=this.style();return this.firstElement.clientHeight-parseFloat(t.paddingTop)-parseFloat(t.paddingBottom)},t.eventListeners={},t}();function x(t){return function(){if("function"==typeof window.CustomEvent)return!1;window.CustomEvent=function(t,e){e=e||{bubbles:!1,cancelable:!1,detail:null};var i=document.createEvent("CustomEvent");return i.initCustomEvent(t,e.bubbles,e.cancelable,e.detail),i}}(),Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),new I(t)}var w=["src","sources","subHtml","subHtmlUrl","html","video","poster","slideName","responsive","srcset","sizes","iframe","downloadUrl","download","width","facebookShareUrl","tweetText","iframeTitle","twitterShareUrl","pinterestShareUrl","pinterestText","fbHtml","disqusIdentifier","disqusUrl"];function S(t){return"href"===t?"src":t=(t=(t=t.replace("data-","")).charAt(0).toLowerCase()+t.slice(1)).replace(/-([a-z])/g,(function(t){return t[1].toUpperCase()}))}var T=function(t,e,i){fetch(t).then((function(t){return t.text()})).then((function(t){if("append"===i){var s='<div class="lg-sub-html">'+t+"</div>";e.append(s)}else e.html(t)}))},E=function(t,e,i,s){void 0===i&&(i=0);var n=x(t).attr("data-lg-size")||s;if(n){var o=n.split(",");if(o[1])for(var r=window.innerWidth,l=0;l<o.length;l++){var a=o[l];if(parseInt(a.split("-")[2],10)>r){n=a;break}l===o.length-1&&(n=a)}var d=n.split("-"),g=parseInt(d[0],10),h=parseInt(d[1],10),c=e.width(),u=e.height()-i,m=Math.min(c,g),p=Math.min(u,h),f=Math.min(m/g,p/h);return{width:g*f,height:h*f}}},O=function(t,e,i,s,n){if(n){var o=x(t).find("img").first();if(o.get()){var r=e.get().getBoundingClientRect(),l=r.width,a=e.height()-(i+s),d=o.width(),g=o.height(),h=o.style(),c=(l-d)/2-o.offset().left+(parseFloat(h.paddingLeft)||0)+(parseFloat(h.borderLeft)||0)+x(window).scrollLeft()+r.left,u=(a-g)/2-o.offset().top+(parseFloat(h.paddingTop)||0)+(parseFloat(h.borderTop)||0)+x(window).scrollTop()+i;return"translate3d("+(c*=-1)+"px, "+(u*=-1)+"px, 0) scale3d("+d/n.width+", "+g/n.height+", 1)"}}},L=function(t,e,i,s,n,o){return'<div class="lg-media-cont lg-has-iframe" style="width:'+t+"; max-width:"+i+"; height: "+e+"; max-height:"+s+'">\n                    <iframe class="lg-object" frameborder="0" '+(o?'title="'+o+'"':"")+' src="'+n+'"  allowfullscreen="true"></iframe>\n                </div>'},D=function(t,e,i,s,n,o){var r="<img "+i+" "+(s?'srcset="'+s+'"':"")+"  "+(n?'sizes="'+n+'"':"")+' class="lg-object lg-image" data-index="'+t+'" src="'+e+'" />',l="";o&&(l=("string"==typeof o?JSON.parse(o):o).map((function(t){var e="";return Object.keys(t).forEach((function(i){e+=" "+i+'="'+t[i]+'"'})),"<source "+e+"></source>"})));return""+l+r},z=function(t){for(var e=[],i=[],s="",n=0;n<t.length;n++){var o=t[n].split(" ");""===o[0]&&o.splice(0,1),i.push(o[0]),e.push(o[1])}for(var r=window.innerWidth,l=0;l<e.length;l++)if(parseInt(e[l],10)>r){s=i[l];break}return s},M=function(t){return!!t&&(!!t.complete&&0!==t.naturalWidth)},G=function(t,e,i,s,n){var o="";o=n&&n.youtube?"lg-has-youtube":n&&n.vimeo?"lg-has-vimeo":"lg-has-html5";var r=e;return"string"!=typeof e&&(r=e.outerHTML),'<div class="lg-video-cont '+o+'" style="'+i+'">\n                <div class="lg-video-play-button">\n                <svg\n                    viewBox="0 0 20 20"\n                    preserveAspectRatio="xMidYMid"\n                    focusable="false"\n                    aria-labelledby="'+s+'"\n                    role="img"\n                    class="lg-video-play-icon"\n                >\n                    <title>'+s+'</title>\n                    <polygon class="lg-video-play-icon-inner" points="1,0 20,10 1,20"></polygon>\n                </svg>\n                <svg class="lg-video-play-icon-bg" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle></svg>\n                <svg class="lg-video-play-icon-circle" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle>\n                </svg>\n            </div>\n            '+r+'\n            <img class="lg-object lg-video-poster" src="'+t+'" />\n        </div>'},k=function(t){var e=t.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])');return[].filter.call(e,(function(t){var e=window.getComputedStyle(t);return"none"!==e.display&&"hidden"!==e.visibility}))},A=function(t,e,i,s){var n=[],o=function(){for(var t=0,e=0,i=arguments.length;e<i;e++)t+=arguments[e].length;var s=Array(t),n=0;for(e=0;e<i;e++)for(var o=arguments[e],r=0,l=o.length;r<l;r++,n++)s[n]=o[r];return s}(w,e);return[].forEach.call(t,(function(t){for(var e={},r=0;r<t.attributes.length;r++){var l=t.attributes[r];if(l.specified){var a=S(l.name),d="";o.indexOf(a)>-1&&(d=a),d&&(e[d]=l.value)}}var g=x(t),h=g.find("img").first().attr("alt"),c=g.attr("title"),u=s?g.attr(s):g.find("img").first().attr("src");e.thumb=u,i&&!e.subHtml&&(e.subHtml=c||h||""),e.alt=h||c||"",n.push(e)})),n},B=function(){return/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)},P=function(t,e,i){if(!t)return e?{html5:!0}:void console.error("lightGallery :- data-src is not provided on slide item "+(i+1)+". Please make sure the selector property is properly configured. More info - https://www.lightgalleryjs.com/demos/html-markup/");var s=t.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)([\&|?][\S]*)*/i),n=t.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)(.*)?/i),o=t.match(/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/([0-9a-z\-_]+)(.*)/);return s?{youtube:s}:n?{vimeo:n}:o?{wistia:o}:void 0},F=0,H=function(){function w(t,e){if(this.lgOpened=!1,this.index=0,this.plugins=[],this.lGalleryOn=!1,this.lgBusy=!1,this.currentItemsInDom=[],this.prevScrollTop=0,this.bodyPaddingRight=0,this.isDummyImageRemoved=!1,this.dragOrSwipeEnabled=!1,this.mediaContainerPosition={top:0,bottom:0},!t)return this;if(F++,this.lgId=F,this.el=t,this.LGel=x(t),this.generateSettings(e),this.buildModules(),this.settings.dynamic&&void 0!==this.settings.dynamicEl&&!Array.isArray(this.settings.dynamicEl))throw"When using dynamic mode, you must also define dynamicEl as an Array.";return this.galleryItems=this.getItems(),this.normalizeSettings(),this.init(),this.validateLicense(),this}return w.prototype.generateSettings=function(e){if(this.settings=t(t({},C),e),this.settings.isMobile&&"function"==typeof this.settings.isMobile?this.settings.isMobile():B()){var i=t(t({},this.settings.mobileSettings),this.settings.mobileSettings);this.settings=t(t({},this.settings),i)}},w.prototype.normalizeSettings=function(){if(this.settings.slideEndAnimation&&(this.settings.hideControlOnEnd=!1),this.settings.closable||(this.settings.swipeToClose=!1),this.zoomFromOrigin=this.settings.zoomFromOrigin,this.settings.dynamic&&(this.zoomFromOrigin=!1),this.settings.container){var t=this.settings.container;if("function"==typeof t)this.settings.container=t();else if("string"==typeof t){var e=document.querySelector(t);this.settings.container=null!=e?e:document.body}}else this.settings.container=document.body;this.settings.preload=Math.min(this.settings.preload,this.galleryItems.length)},w.prototype.init=function(){var t=this;this.addSlideVideoInfo(this.galleryItems),this.buildStructure(),this.LGel.trigger(i,{instance:this}),this.settings.keyPress&&this.keyPress(),setTimeout((function(){t.enableDrag(),t.enableSwipe(),t.triggerPosterClick()}),50),this.arrow(),this.settings.mousewheel&&this.mousewheel(),this.settings.dynamic||this.openGalleryOnItemClick()},w.prototype.openGalleryOnItemClick=function(){for(var t=this,e=function(e){var s=i.items[e],n=x(s),o=I.generateUUID();n.attr("data-lg-id",o).on("click.lgcustom-item-"+o,(function(i){i.preventDefault();var n=t.settings.index||e;t.openGallery(n,s)}))},i=this,s=0;s<this.items.length;s++)e(s)},w.prototype.buildModules=function(){var t=this;this.settings.plugins.forEach((function(e){t.plugins.push(new e(t,x))}))},w.prototype.validateLicense=function(){this.settings.licenseKey?"0000-0000-000-0000"===this.settings.licenseKey&&console.warn("lightGallery: "+this.settings.licenseKey+" license key is not valid for production use"):console.error("Please provide a valid license key")},w.prototype.getSlideItem=function(t){return x(this.getSlideItemId(t))},w.prototype.getSlideItemId=function(t){return"#lg-item-"+this.lgId+"-"+t},w.prototype.getIdName=function(t){return t+"-"+this.lgId},w.prototype.getElementById=function(t){return x("#"+this.getIdName(t))},w.prototype.manageSingleSlideClassName=function(){this.galleryItems.length<2?this.outer.addClass("lg-single-item"):this.outer.removeClass("lg-single-item")},w.prototype.buildStructure=function(){var t=this;if(!(this.$container&&this.$container.get())){var e="",i="";this.settings.controls&&(e='<button type="button" id="'+this.getIdName("lg-prev")+'" aria-label="'+this.settings.strings.previousSlide+'" class="lg-prev lg-icon"> '+this.settings.prevHtml+' </button>\n                <button type="button" id="'+this.getIdName("lg-next")+'" aria-label="'+this.settings.strings.nextSlide+'" class="lg-next lg-icon"> '+this.settings.nextHtml+" </button>"),".lg-item"!==this.settings.appendSubHtmlTo&&(i='<div class="lg-sub-html" role="status" aria-live="polite"></div>');var s="";this.settings.allowMediaOverlap&&(s+="lg-media-overlap ");var n=this.settings.ariaLabelledby?'aria-labelledby="'+this.settings.ariaLabelledby+'"':"",o=this.settings.ariaDescribedby?'aria-describedby="'+this.settings.ariaDescribedby+'"':"",r="lg-container "+this.settings.addClass+" "+(document.body!==this.settings.container?"lg-inline":""),l=this.settings.closable&&this.settings.showCloseIcon?'<button type="button" aria-label="'+this.settings.strings.closeGallery+'" id="'+this.getIdName("lg-close")+'" class="lg-close lg-icon"></button>':"",a=this.settings.showMaximizeIcon?'<button type="button" aria-label="'+this.settings.strings.toggleMaximize+'" id="'+this.getIdName("lg-maximize")+'" class="lg-maximize lg-icon"></button>':"",d='\n        <div class="'+r+'" id="'+this.getIdName("lg-container")+'" tabindex="-1" aria-modal="true" '+n+" "+o+' role="dialog"\n        >\n            <div id="'+this.getIdName("lg-backdrop")+'" class="lg-backdrop"></div>\n\n            <div id="'+this.getIdName("lg-outer")+'" class="lg-outer lg-use-css3 lg-css3 lg-hide-items '+s+' ">\n\n              <div id="'+this.getIdName("lg-content")+'" class="lg-content">\n                <div id="'+this.getIdName("lg-inner")+'" class="lg-inner">\n                </div>\n                '+e+'\n              </div>\n                <div id="'+this.getIdName("lg-toolbar")+'" class="lg-toolbar lg-group">\n                    '+a+"\n                    "+l+"\n                    </div>\n                    "+(".lg-outer"===this.settings.appendSubHtmlTo?i:"")+'\n                <div id="'+this.getIdName("lg-components")+'" class="lg-components">\n                    '+(".lg-sub-html"===this.settings.appendSubHtmlTo?i:"")+"\n                </div>\n            </div>\n        </div>\n        ";x(this.settings.container).append(d),document.body!==this.settings.container&&x(this.settings.container).css("position","relative"),this.outer=this.getElementById("lg-outer"),this.$lgComponents=this.getElementById("lg-components"),this.$backdrop=this.getElementById("lg-backdrop"),this.$container=this.getElementById("lg-container"),this.$inner=this.getElementById("lg-inner"),this.$content=this.getElementById("lg-content"),this.$toolbar=this.getElementById("lg-toolbar"),this.$backdrop.css("transition-duration",this.settings.backdropDuration+"ms");var g=this.settings.mode+" ";this.manageSingleSlideClassName(),this.settings.enableDrag&&(g+="lg-grab "),this.outer.addClass(g),this.$inner.css("transition-timing-function",this.settings.easing),this.$inner.css("transition-duration",this.settings.speed+"ms"),this.settings.download&&this.$toolbar.append('<a id="'+this.getIdName("lg-download")+'" target="_blank" rel="noopener" aria-label="'+this.settings.strings.download+'" download class="lg-download lg-icon"></a>'),this.counter(),x(window).on("resize.lg.global"+this.lgId+" orientationchange.lg.global"+this.lgId,(function(){t.refreshOnResize()})),this.hideBars(),this.manageCloseGallery(),this.toggleMaximize(),this.initModules()}},w.prototype.refreshOnResize=function(){if(this.lgOpened){var t=this.galleryItems[this.index].__slideVideoInfo;this.mediaContainerPosition=this.getMediaContainerPosition();var e=this.mediaContainerPosition,i=e.top,s=e.bottom;if(this.currentImageSize=E(this.items[this.index],this.outer,i+s,t&&this.settings.videoMaxSize),t&&this.resizeVideoSlide(this.index,this.currentImageSize),this.zoomFromOrigin&&!this.isDummyImageRemoved){var o=this.getDummyImgStyles(this.currentImageSize);this.outer.find(".lg-current .lg-dummy-img").first().attr("style",o)}this.LGel.trigger(n)}},w.prototype.resizeVideoSlide=function(t,e){var i=this.getVideoContStyle(e);this.getSlideItem(t).find(".lg-video-cont").attr("style",i)},w.prototype.updateSlides=function(t,e){if(this.index>t.length-1&&(this.index=t.length-1),1===t.length&&(this.index=0),t.length){var i=this.galleryItems[e].src;this.galleryItems=t,this.updateControls(),this.$inner.empty(),this.currentItemsInDom=[];var s=0;this.galleryItems.some((function(t,e){return t.src===i&&(s=e,!0)})),this.currentItemsInDom=this.organizeSlideItems(s,-1),this.loadContent(s,!0),this.getSlideItem(s).addClass("lg-current"),this.index=s,this.updateCurrentCounter(s),this.LGel.trigger(o)}else this.closeGallery()},w.prototype.getItems=function(){if(this.items=[],this.settings.dynamic)return this.settings.dynamicEl||[];if("this"===this.settings.selector)this.items.push(this.el);else if(this.settings.selector)if("string"==typeof this.settings.selector)if(this.settings.selectWithin){var t=x(this.settings.selectWithin);this.items=t.find(this.settings.selector).get()}else this.items=this.el.querySelectorAll(this.settings.selector);else this.items=this.settings.selector;else this.items=this.el.children;return A(this.items,this.settings.extraProps,this.settings.getCaptionFromTitleOrAlt,this.settings.exThumbImage)},w.prototype.shouldHideScrollbar=function(){return this.settings.hideScrollbar&&document.body===this.settings.container},w.prototype.hideScrollbar=function(){if(this.shouldHideScrollbar()){this.bodyPaddingRight=parseFloat(x("body").style().paddingRight);var t=document.documentElement.getBoundingClientRect(),e=window.innerWidth-t.width;x(document.body).css("padding-right",e+this.bodyPaddingRight+"px"),x(document.body).addClass("lg-overlay-open")}},w.prototype.resetScrollBar=function(){this.shouldHideScrollbar()&&(x(document.body).css("padding-right",this.bodyPaddingRight+"px"),x(document.body).removeClass("lg-overlay-open"))},w.prototype.openGallery=function(t,e){var i=this;if(void 0===t&&(t=this.settings.index),!this.lgOpened){this.lgOpened=!0,this.outer.removeClass("lg-hide-items"),this.hideScrollbar(),this.$container.addClass("lg-show");var s=this.getItemsToBeInsertedToDom(t,t);this.currentItemsInDom=s;var n="";s.forEach((function(t){n=n+'<div id="'+t+'" class="lg-item"></div>'})),this.$inner.append(n),this.addHtml(t);var o="";this.mediaContainerPosition=this.getMediaContainerPosition();var r=this.mediaContainerPosition,d=r.top,g=r.bottom;this.settings.allowMediaOverlap||this.setMediaContainerPosition(d,g);var h=this.galleryItems[t].__slideVideoInfo;this.zoomFromOrigin&&e&&(this.currentImageSize=E(e,this.outer,d+g,h&&this.settings.videoMaxSize),o=O(e,this.outer,d,g,this.currentImageSize)),this.zoomFromOrigin&&o||(this.outer.addClass(this.settings.startClass),this.getSlideItem(t).removeClass("lg-complete"));var c=this.settings.zoomFromOrigin?100:this.settings.backdropDuration;setTimeout((function(){i.outer.addClass("lg-components-open")}),c),this.index=t,this.LGel.trigger(l),this.getSlideItem(t).addClass("lg-current"),this.lGalleryOn=!1,this.prevScrollTop=x(window).scrollTop(),setTimeout((function(){if(i.zoomFromOrigin&&o){var e=i.getSlideItem(t);e.css("transform",o),setTimeout((function(){e.addClass("lg-start-progress lg-start-end-progress").css("transition-duration",i.settings.startAnimationDuration+"ms"),i.outer.addClass("lg-zoom-from-image")})),setTimeout((function(){e.css("transform","translate3d(0, 0, 0)")}),100)}setTimeout((function(){i.$backdrop.addClass("in"),i.$container.addClass("lg-show-in")}),10),setTimeout((function(){i.settings.trapFocus&&document.body===i.settings.container&&i.trapFocus()}),i.settings.backdropDuration+50),i.zoomFromOrigin&&o||setTimeout((function(){i.outer.addClass("lg-visible")}),i.settings.backdropDuration),i.slide(t,!1,!1,!1),i.LGel.trigger(a)})),document.body===this.settings.container&&x("html").addClass("lg-on")}},w.prototype.getMediaContainerPosition=function(){if(this.settings.allowMediaOverlap)return{top:0,bottom:0};var t=this.$toolbar.get().clientHeight||0,e=this.outer.find(".lg-components .lg-sub-html").get(),i=this.settings.defaultCaptionHeight||e&&e.clientHeight||0,s=this.outer.find(".lg-thumb-outer").get();return{top:t,bottom:(s?s.clientHeight:0)+i}},w.prototype.setMediaContainerPosition=function(t,e){void 0===t&&(t=0),void 0===e&&(e=0),this.$content.css("top",t+"px").css("bottom",e+"px")},w.prototype.hideBars=function(){var t=this;setTimeout((function(){t.outer.removeClass("lg-hide-items"),t.settings.hideBarsDelay>0&&(t.outer.on("mousemove.lg click.lg touchstart.lg",(function(){t.outer.removeClass("lg-hide-items"),clearTimeout(t.hideBarTimeout),t.hideBarTimeout=setTimeout((function(){t.outer.addClass("lg-hide-items")}),t.settings.hideBarsDelay)})),t.outer.trigger("mousemove.lg"))}),this.settings.showBarsAfter)},w.prototype.initPictureFill=function(t){if(this.settings.supportLegacyBrowser)try{picturefill({elements:[t.get()]})}catch(t){console.warn("lightGallery :- If you want srcset or picture tag to be supported for older browser please include picturefil javascript library in your document.")}},w.prototype.counter=function(){if(this.settings.counter){var t='<div class="lg-counter" role="status" aria-live="polite">\n                <span id="'+this.getIdName("lg-counter-current")+'" class="lg-counter-current">'+(this.index+1)+' </span> /\n                <span id="'+this.getIdName("lg-counter-all")+'" class="lg-counter-all">'+this.galleryItems.length+" </span></div>";this.outer.find(this.settings.appendCounterTo).append(t)}},w.prototype.addHtml=function(t){var e,i;if(this.galleryItems[t].subHtmlUrl?i=this.galleryItems[t].subHtmlUrl:e=this.galleryItems[t].subHtml,!i)if(e){var s=e.substring(0,1);"."!==s&&"#"!==s||(e=this.settings.subHtmlSelectorRelative&&!this.settings.dynamic?x(this.items).eq(t).find(e).first().html():x(e).first().html())}else e="";if(".lg-item"!==this.settings.appendSubHtmlTo)i?T(i,this.outer.find(".lg-sub-html"),"replace"):this.outer.find(".lg-sub-html").html(e);else{var n=x(this.getSlideItemId(t));i?T(i,n,"append"):n.append('<div class="lg-sub-html">'+e+"</div>")}null!=e&&(""===e?this.outer.find(this.settings.appendSubHtmlTo).addClass("lg-empty-html"):this.outer.find(this.settings.appendSubHtmlTo).removeClass("lg-empty-html")),this.LGel.trigger(r,{index:t})},w.prototype.preload=function(t){for(var e=1;e<=this.settings.preload&&!(e>=this.galleryItems.length-t);e++)this.loadContent(t+e,!1);for(var i=1;i<=this.settings.preload&&!(t-i<0);i++)this.loadContent(t-i,!1)},w.prototype.getDummyImgStyles=function(t){return t?"width:"+t.width+"px;\n                margin-left: -"+t.width/2+"px;\n                margin-top: -"+t.height/2+"px;\n                height:"+t.height+"px":""},w.prototype.getVideoContStyle=function(t){return t?"width:"+t.width+"px;\n                height:"+t.height+"px":""},w.prototype.getDummyImageContent=function(t,e,i){var s;if(this.settings.dynamic||(s=x(this.items).eq(e)),s){var n=void 0;if(!(n=this.settings.exThumbImage?s.attr(this.settings.exThumbImage):s.find("img").first().attr("src")))return"";var o=this.getDummyImgStyles(this.currentImageSize),r=document.createElement("img");return r.alt=i||"",r.src=n,r.className="lg-dummy-img",r.style.cssText=o,t.addClass("lg-first-slide"),this.outer.addClass("lg-first-slide-loading"),r}return""},w.prototype.setImgMarkup=function(t,e,i){var s=this.galleryItems[i],n=s.alt,o=s.srcset,r=s.sizes,l=s.sources,a="",d=n?'alt="'+n+'"':"";a=this.isFirstSlideWithZoomAnimation()?this.getDummyImageContent(e,i,d):D(i,t,d,o,r,l);var g=document.createElement("picture");g.className="lg-img-wrap",x(g).append(a),e.prepend(g)},w.prototype.onSlideObjectLoad=function(t,e,i,s){var n=t.find(".lg-object").first();M(n.get())||e?i():(n.on("load.lg error.lg",(function(){i&&i()})),n.on("error.lg",(function(){s&&s()})))},w.prototype.onLgObjectLoad=function(t,e,i,s,n,o){var r=this;this.onSlideObjectLoad(t,o,(function(){r.triggerSlideItemLoad(t,e,i,s,n)}),(function(){t.addClass("lg-complete lg-complete_"),t.html('<span class="lg-error-msg">'+r.settings.strings.mediaLoadingFailed+"</span>")}))},w.prototype.triggerSlideItemLoad=function(t,e,i,s,n){var o=this,r=this.galleryItems[e],l=n&&"video"===this.getSlideType(r)&&!r.poster?s:0;setTimeout((function(){t.addClass("lg-complete lg-complete_"),o.LGel.trigger(d,{index:e,delay:i||0,isFirstSlide:n})}),l)},w.prototype.isFirstSlideWithZoomAnimation=function(){return!(this.lGalleryOn||!this.zoomFromOrigin||!this.currentImageSize)},w.prototype.addSlideVideoInfo=function(t){var e=this;t.forEach((function(t,i){t.__slideVideoInfo=P(t.src,!!t.video,i),t.__slideVideoInfo&&e.settings.loadYouTubePoster&&!t.poster&&t.__slideVideoInfo.youtube&&(t.poster="//img.youtube.com/vi/"+t.__slideVideoInfo.youtube[1]+"/maxresdefault.jpg")}))},w.prototype.loadContent=function(t,i){var n=this,o=this.galleryItems[t],r=x(this.getSlideItemId(t)),l=o.poster,a=o.srcset,d=o.sizes,g=o.sources,h=o.src,c=o.video,u=c&&"string"==typeof c?JSON.parse(c):c;if(o.responsive){var m=o.responsive.split(",");h=z(m)||h}var p=o.__slideVideoInfo,f="",y=!!o.iframe,v=!this.lGalleryOn,b=0;if(v&&(b=this.zoomFromOrigin&&this.currentImageSize?this.settings.startAnimationDuration+10:this.settings.backdropDuration+10),!r.hasClass("lg-loaded")){if(p){var C=this.mediaContainerPosition,I=C.top,w=C.bottom,S=E(this.items[t],this.outer,I+w,p&&this.settings.videoMaxSize);f=this.getVideoContStyle(S)}if(y){var T=L(this.settings.iframeWidth,this.settings.iframeHeight,this.settings.iframeMaxWidth,this.settings.iframeMaxHeight,h,o.iframeTitle);r.prepend(T)}else if(l){var O="";v&&this.zoomFromOrigin&&this.currentImageSize&&(O=this.getDummyImageContent(r,t,""));T=G(l,O||"",f,this.settings.strings.playVideo,p);r.prepend(T)}else if(p){T='<div class="lg-video-cont " style="'+f+'"></div>';r.prepend(T)}else if(this.setImgMarkup(h,r,t),a||g){var M=r.find(".lg-object");this.initPictureFill(M)}(l||p)&&this.LGel.trigger(s,{index:t,src:h,html5Video:u,hasPoster:!!l}),this.LGel.trigger(e,{index:t}),this.lGalleryOn&&".lg-item"===this.settings.appendSubHtmlTo&&this.addHtml(t)}var k=0;b&&!x(document.body).hasClass("lg-from-hash")&&(k=b),this.isFirstSlideWithZoomAnimation()&&(setTimeout((function(){r.removeClass("lg-start-end-progress lg-start-progress").removeAttr("style")}),this.settings.startAnimationDuration+100),r.hasClass("lg-loaded")||setTimeout((function(){if("image"===n.getSlideType(o)){var e=o.alt,i=e?'alt="'+e+'"':"";if(r.find(".lg-img-wrap").append(D(t,h,i,a,d,o.sources)),a||g){var s=r.find(".lg-object");n.initPictureFill(s)}}("image"===n.getSlideType(o)||"video"===n.getSlideType(o)&&l)&&(n.onLgObjectLoad(r,t,b,k,!0,!1),n.onSlideObjectLoad(r,!(!p||!p.html5||l),(function(){n.loadContentOnFirstSlideLoad(t,r,k)}),(function(){n.loadContentOnFirstSlideLoad(t,r,k)})))}),this.settings.startAnimationDuration+100)),r.addClass("lg-loaded"),this.isFirstSlideWithZoomAnimation()&&("video"!==this.getSlideType(o)||l)||this.onLgObjectLoad(r,t,b,k,v,!(!p||!p.html5||l)),this.zoomFromOrigin&&this.currentImageSize||!r.hasClass("lg-complete_")||this.lGalleryOn||setTimeout((function(){r.addClass("lg-complete")}),this.settings.backdropDuration),this.lGalleryOn=!0,!0===i&&(r.hasClass("lg-complete_")?this.preload(t):r.find(".lg-object").first().on("load.lg error.lg",(function(){n.preload(t)})))},w.prototype.loadContentOnFirstSlideLoad=function(t,e,i){var s=this;setTimeout((function(){e.find(".lg-dummy-img").remove(),e.removeClass("lg-first-slide"),s.outer.removeClass("lg-first-slide-loading"),s.isDummyImageRemoved=!0,s.preload(t)}),i+300)},w.prototype.getItemsToBeInsertedToDom=function(t,e,i){var s=this;void 0===i&&(i=0);var n=[],o=Math.max(i,3);o=Math.min(o,this.galleryItems.length);var r="lg-item-"+this.lgId+"-"+e;if(this.galleryItems.length<=3)return this.galleryItems.forEach((function(t,e){n.push("lg-item-"+s.lgId+"-"+e)})),n;if(t<(this.galleryItems.length-1)/2){for(var l=t;l>t-o/2&&l>=0;l--)n.push("lg-item-"+this.lgId+"-"+l);var a=n.length;for(l=0;l<o-a;l++)n.push("lg-item-"+this.lgId+"-"+(t+l+1))}else{for(l=t;l<=this.galleryItems.length-1&&l<t+o/2;l++)n.push("lg-item-"+this.lgId+"-"+l);for(a=n.length,l=0;l<o-a;l++)n.push("lg-item-"+this.lgId+"-"+(t-l-1))}return this.settings.loop&&(t===this.galleryItems.length-1?n.push("lg-item-"+this.lgId+"-0"):0===t&&n.push("lg-item-"+this.lgId+"-"+(this.galleryItems.length-1))),-1===n.indexOf(r)&&n.push("lg-item-"+this.lgId+"-"+e),n},w.prototype.organizeSlideItems=function(t,e){var i=this,s=this.getItemsToBeInsertedToDom(t,e,this.settings.numberOfSlideItemsInDom);return s.forEach((function(t){-1===i.currentItemsInDom.indexOf(t)&&i.$inner.append('<div id="'+t+'" class="lg-item"></div>')})),this.currentItemsInDom.forEach((function(t){-1===s.indexOf(t)&&x("#"+t).remove()})),s},w.prototype.getPreviousSlideIndex=function(){var t=0;try{var e=this.outer.find(".lg-current").first().attr("id");t=parseInt(e.split("-")[3])||0}catch(e){t=0}return t},w.prototype.setDownloadValue=function(t){if(this.settings.download){var e=this.galleryItems[t];if(!1===e.downloadUrl||"false"===e.downloadUrl)this.outer.addClass("lg-hide-download");else{var i=this.getElementById("lg-download");this.outer.removeClass("lg-hide-download"),i.attr("href",e.downloadUrl||e.src),e.download&&i.attr("download",e.download)}}},w.prototype.makeSlideAnimation=function(t,e,i){var s=this;this.lGalleryOn&&i.addClass("lg-slide-progress"),setTimeout((function(){s.outer.addClass("lg-no-trans"),s.outer.find(".lg-item").removeClass("lg-prev-slide lg-next-slide"),"prev"===t?(e.addClass("lg-prev-slide"),i.addClass("lg-next-slide")):(e.addClass("lg-next-slide"),i.addClass("lg-prev-slide")),setTimeout((function(){s.outer.find(".lg-item").removeClass("lg-current"),e.addClass("lg-current"),s.outer.removeClass("lg-no-trans")}),50)}),this.lGalleryOn?this.settings.slideDelay:0)},w.prototype.slide=function(t,e,i,s){var n=this,o=this.getPreviousSlideIndex();if(this.currentItemsInDom=this.organizeSlideItems(t,o),!this.lGalleryOn||o!==t){var r=this.galleryItems.length;if(!this.lgBusy){this.settings.counter&&this.updateCurrentCounter(t);var l=this.getSlideItem(t),a=this.getSlideItem(o),d=this.galleryItems[t],c=d.__slideVideoInfo;if(this.outer.attr("data-lg-slide-type",this.getSlideType(d)),this.setDownloadValue(t),c){var u=this.mediaContainerPosition,m=u.top,p=u.bottom,f=E(this.items[t],this.outer,m+p,c&&this.settings.videoMaxSize);this.resizeVideoSlide(t,f)}if(this.LGel.trigger(g,{prevIndex:o,index:t,fromTouch:!!e,fromThumb:!!i}),this.lgBusy=!0,clearTimeout(this.hideBarTimeout),this.arrowDisable(t),s||(t<o?s="prev":t>o&&(s="next")),e){this.outer.find(".lg-item").removeClass("lg-prev-slide lg-current lg-next-slide");var y=void 0,v=void 0;r>2?(y=t-1,v=t+1,(0===t&&o===r-1||t===r-1&&0===o)&&(v=0,y=r-1)):(y=0,v=1),"prev"===s?this.getSlideItem(v).addClass("lg-next-slide"):this.getSlideItem(y).addClass("lg-prev-slide"),l.addClass("lg-current")}else this.makeSlideAnimation(s,l,a);this.lGalleryOn?setTimeout((function(){n.loadContent(t,!0),".lg-item"!==n.settings.appendSubHtmlTo&&n.addHtml(t)}),this.settings.speed+50+(e?0:this.settings.slideDelay)):this.loadContent(t,!0),setTimeout((function(){n.lgBusy=!1,a.removeClass("lg-slide-progress"),n.LGel.trigger(h,{prevIndex:o,index:t,fromTouch:e,fromThumb:i})}),(this.lGalleryOn?this.settings.speed+100:100)+(e?0:this.settings.slideDelay))}this.index=t}},w.prototype.updateCurrentCounter=function(t){this.getElementById("lg-counter-current").html(t+1+"")},w.prototype.updateCounterTotal=function(){this.getElementById("lg-counter-all").html(this.galleryItems.length+"")},w.prototype.getSlideType=function(t){return t.__slideVideoInfo?"video":t.iframe?"iframe":"image"},w.prototype.touchMove=function(t,e,i){var s=e.pageX-t.pageX,n=e.pageY-t.pageY,o=!1;if(this.swipeDirection?o=!0:Math.abs(s)>15?(this.swipeDirection="horizontal",o=!0):Math.abs(n)>15&&(this.swipeDirection="vertical",o=!0),o){var r=this.getSlideItem(this.index);if("horizontal"===this.swipeDirection){null==i||i.preventDefault(),this.outer.addClass("lg-dragging"),this.setTranslate(r,s,0);var l=r.get().offsetWidth,a=15*l/100-Math.abs(10*s/100);this.setTranslate(this.outer.find(".lg-prev-slide").first(),-l+s-a,0),this.setTranslate(this.outer.find(".lg-next-slide").first(),l+s+a,0)}else if("vertical"===this.swipeDirection&&this.settings.swipeToClose){null==i||i.preventDefault(),this.$container.addClass("lg-dragging-vertical");var d=1-Math.abs(n)/window.innerHeight;this.$backdrop.css("opacity",d);var g=1-Math.abs(n)/(2*window.innerWidth);this.setTranslate(r,0,n,g,g),Math.abs(n)>100&&this.outer.addClass("lg-hide-items").removeClass("lg-components-open")}}},w.prototype.touchEnd=function(t,e,i){var s,n=this;"lg-slide"!==this.settings.mode&&this.outer.addClass("lg-slide"),setTimeout((function(){n.$container.removeClass("lg-dragging-vertical"),n.outer.removeClass("lg-dragging lg-hide-items").addClass("lg-components-open");var o=!0;if("horizontal"===n.swipeDirection){s=t.pageX-e.pageX;var r=Math.abs(t.pageX-e.pageX);s<0&&r>n.settings.swipeThreshold?(n.goToNextSlide(!0),o=!1):s>0&&r>n.settings.swipeThreshold&&(n.goToPrevSlide(!0),o=!1)}else if("vertical"===n.swipeDirection){if(s=Math.abs(t.pageY-e.pageY),n.settings.closable&&n.settings.swipeToClose&&s>100)return void n.closeGallery();n.$backdrop.css("opacity",1)}if(n.outer.find(".lg-item").removeAttr("style"),o&&Math.abs(t.pageX-e.pageX)<5){var l=x(i.target);n.isPosterElement(l)&&n.LGel.trigger(c)}n.swipeDirection=void 0})),setTimeout((function(){n.outer.hasClass("lg-dragging")||"lg-slide"===n.settings.mode||n.outer.removeClass("lg-slide")}),this.settings.speed+100)},w.prototype.enableSwipe=function(){var t=this,e={},i={},s=!1,n=!1;this.settings.enableSwipe&&(this.$inner.on("touchstart.lg",(function(i){t.dragOrSwipeEnabled=!0;var s=t.getSlideItem(t.index);!x(i.target).hasClass("lg-item")&&!s.get().contains(i.target)||t.outer.hasClass("lg-zoomed")||t.lgBusy||1!==i.touches.length||(n=!0,t.touchAction="swipe",t.manageSwipeClass(),e={pageX:i.touches[0].pageX,pageY:i.touches[0].pageY})})),this.$inner.on("touchmove.lg",(function(o){n&&"swipe"===t.touchAction&&1===o.touches.length&&(i={pageX:o.touches[0].pageX,pageY:o.touches[0].pageY},t.touchMove(e,i,o),s=!0)})),this.$inner.on("touchend.lg",(function(o){if("swipe"===t.touchAction){if(s)s=!1,t.touchEnd(i,e,o);else if(n){var r=x(o.target);t.isPosterElement(r)&&t.LGel.trigger(c)}t.touchAction=void 0,n=!1}})))},w.prototype.enableDrag=function(){var t=this,e={},i={},s=!1,n=!1;this.settings.enableDrag&&(this.outer.on("mousedown.lg",(function(i){t.dragOrSwipeEnabled=!0;var n=t.getSlideItem(t.index);(x(i.target).hasClass("lg-item")||n.get().contains(i.target))&&(t.outer.hasClass("lg-zoomed")||t.lgBusy||(i.preventDefault(),t.lgBusy||(t.manageSwipeClass(),e={pageX:i.pageX,pageY:i.pageY},s=!0,t.outer.get().scrollLeft+=1,t.outer.get().scrollLeft-=1,t.outer.removeClass("lg-grab").addClass("lg-grabbing"),t.LGel.trigger(u))))})),x(window).on("mousemove.lg.global"+this.lgId,(function(o){s&&t.lgOpened&&(n=!0,i={pageX:o.pageX,pageY:o.pageY},t.touchMove(e,i),t.LGel.trigger(m))})),x(window).on("mouseup.lg.global"+this.lgId,(function(o){if(t.lgOpened){var r=x(o.target);n?(n=!1,t.touchEnd(i,e,o),t.LGel.trigger(p)):t.isPosterElement(r)&&t.LGel.trigger(c),s&&(s=!1,t.outer.removeClass("lg-grabbing").addClass("lg-grab"))}})))},w.prototype.triggerPosterClick=function(){var t=this;this.$inner.on("click.lg",(function(e){!t.dragOrSwipeEnabled&&t.isPosterElement(x(e.target))&&t.LGel.trigger(c)}))},w.prototype.manageSwipeClass=function(){var t=this.index+1,e=this.index-1;this.settings.loop&&this.galleryItems.length>2&&(0===this.index?e=this.galleryItems.length-1:this.index===this.galleryItems.length-1&&(t=0)),this.outer.find(".lg-item").removeClass("lg-next-slide lg-prev-slide"),e>-1&&this.getSlideItem(e).addClass("lg-prev-slide"),this.getSlideItem(t).addClass("lg-next-slide")},w.prototype.goToNextSlide=function(t){var e=this,i=this.settings.loop;t&&this.galleryItems.length<3&&(i=!1),this.lgBusy||(this.index+1<this.galleryItems.length?(this.index++,this.LGel.trigger(f,{index:this.index}),this.slide(this.index,!!t,!1,"next")):i?(this.index=0,this.LGel.trigger(f,{index:this.index}),this.slide(this.index,!!t,!1,"next")):this.settings.slideEndAnimation&&!t&&(this.outer.addClass("lg-right-end"),setTimeout((function(){e.outer.removeClass("lg-right-end")}),400)))},w.prototype.goToPrevSlide=function(t){var e=this,i=this.settings.loop;t&&this.galleryItems.length<3&&(i=!1),this.lgBusy||(this.index>0?(this.index--,this.LGel.trigger(y,{index:this.index,fromTouch:t}),this.slide(this.index,!!t,!1,"prev")):i?(this.index=this.galleryItems.length-1,this.LGel.trigger(y,{index:this.index,fromTouch:t}),this.slide(this.index,!!t,!1,"prev")):this.settings.slideEndAnimation&&!t&&(this.outer.addClass("lg-left-end"),setTimeout((function(){e.outer.removeClass("lg-left-end")}),400)))},w.prototype.keyPress=function(){var t=this;x(window).on("keydown.lg.global"+this.lgId,(function(e){t.lgOpened&&!0===t.settings.escKey&&27===e.keyCode&&(e.preventDefault(),t.settings.allowMediaOverlap&&t.outer.hasClass("lg-can-toggle")&&t.outer.hasClass("lg-components-open")?t.outer.removeClass("lg-components-open"):t.closeGallery()),t.lgOpened&&t.galleryItems.length>1&&(37===e.keyCode&&(e.preventDefault(),t.goToPrevSlide()),39===e.keyCode&&(e.preventDefault(),t.goToNextSlide()))}))},w.prototype.arrow=function(){var t=this;this.getElementById("lg-prev").on("click.lg",(function(){t.goToPrevSlide()})),this.getElementById("lg-next").on("click.lg",(function(){t.goToNextSlide()}))},w.prototype.arrowDisable=function(t){if(!this.settings.loop&&this.settings.hideControlOnEnd){var e=this.getElementById("lg-prev"),i=this.getElementById("lg-next");t+1===this.galleryItems.length?i.attr("disabled","disabled").addClass("disabled"):i.removeAttr("disabled").removeClass("disabled"),0===t?e.attr("disabled","disabled").addClass("disabled"):e.removeAttr("disabled").removeClass("disabled")}},w.prototype.setTranslate=function(t,e,i,s,n){void 0===s&&(s=1),void 0===n&&(n=1),t.css("transform","translate3d("+e+"px, "+i+"px, 0px) scale3d("+s+", "+n+", 1)")},w.prototype.mousewheel=function(){var t=this,e=0;this.outer.on("wheel.lg",(function(i){if(i.deltaY&&!(t.galleryItems.length<2)){i.preventDefault();var s=(new Date).getTime();s-e<1e3||(e=s,i.deltaY>0?t.goToNextSlide():i.deltaY<0&&t.goToPrevSlide())}}))},w.prototype.isSlideElement=function(t){return t.hasClass("lg-outer")||t.hasClass("lg-item")||t.hasClass("lg-img-wrap")||t.hasClass("lg-img-rotate")},w.prototype.isPosterElement=function(t){var e=this.getSlideItem(this.index).find(".lg-video-play-button").get();return t.hasClass("lg-video-poster")||t.hasClass("lg-video-play-button")||e&&e.contains(t.get())},w.prototype.toggleMaximize=function(){var t=this;this.getElementById("lg-maximize").on("click.lg",(function(){t.$container.toggleClass("lg-inline"),t.refreshOnResize()}))},w.prototype.invalidateItems=function(){for(var t=0;t<this.items.length;t++){var e=x(this.items[t]);e.off("click.lgcustom-item-"+e.attr("data-lg-id"))}},w.prototype.trapFocus=function(){var t=this;this.$container.get().focus({preventScroll:!0}),x(window).on("keydown.lg.global"+this.lgId,(function(e){if(t.lgOpened&&("Tab"===e.key||9===e.keyCode)){var i=k(t.$container.get()),s=i[0],n=i[i.length-1];e.shiftKey?document.activeElement===s&&(n.focus(),e.preventDefault()):document.activeElement===n&&(s.focus(),e.preventDefault())}}))},w.prototype.manageCloseGallery=function(){var t=this;if(this.settings.closable){var e=!1;this.getElementById("lg-close").on("click.lg",(function(){t.closeGallery()})),this.settings.closeOnTap&&(this.outer.on("mousedown.lg",(function(i){var s=x(i.target);e=!!t.isSlideElement(s)})),this.outer.on("mousemove.lg",(function(){e=!1})),this.outer.on("mouseup.lg",(function(i){var s=x(i.target);t.isSlideElement(s)&&e&&(t.outer.hasClass("lg-dragging")||t.closeGallery())})))}},w.prototype.closeGallery=function(t){var e=this;if(!this.lgOpened||!this.settings.closable&&!t)return 0;this.LGel.trigger(v),this.settings.resetScrollPosition&&!this.settings.hideScrollbar&&x(window).scrollTop(this.prevScrollTop);var i,s=this.items[this.index];if(this.zoomFromOrigin&&s){var n=this.mediaContainerPosition,o=n.top,r=n.bottom,l=this.galleryItems[this.index],a=l.__slideVideoInfo,d=l.poster,g=E(s,this.outer,o+r,a&&d&&this.settings.videoMaxSize);i=O(s,this.outer,o,r,g)}this.zoomFromOrigin&&i?(this.outer.addClass("lg-closing lg-zoom-from-image"),this.getSlideItem(this.index).addClass("lg-start-end-progress").css("transition-duration",this.settings.startAnimationDuration+"ms").css("transform",i)):(this.outer.addClass("lg-hide-items"),this.outer.removeClass("lg-zoom-from-image")),this.destroyModules(),this.lGalleryOn=!1,this.isDummyImageRemoved=!1,this.zoomFromOrigin=this.settings.zoomFromOrigin,clearTimeout(this.hideBarTimeout),this.hideBarTimeout=!1,x("html").removeClass("lg-on"),this.outer.removeClass("lg-visible lg-components-open"),this.$backdrop.removeClass("in").css("opacity",0);var h=this.zoomFromOrigin&&i?Math.max(this.settings.startAnimationDuration,this.settings.backdropDuration):this.settings.backdropDuration;return this.$container.removeClass("lg-show-in"),setTimeout((function(){e.zoomFromOrigin&&i&&e.outer.removeClass("lg-zoom-from-image"),e.$container.removeClass("lg-show"),e.resetScrollBar(),e.$backdrop.removeAttr("style").css("transition-duration",e.settings.backdropDuration+"ms"),e.outer.removeClass("lg-closing "+e.settings.startClass),e.getSlideItem(e.index).removeClass("lg-start-end-progress"),e.$inner.empty(),e.lgOpened&&e.LGel.trigger(b,{instance:e}),e.$container.get()&&e.$container.get().blur(),e.lgOpened=!1}),h+100),h+100},w.prototype.initModules=function(){this.plugins.forEach((function(t){try{t.init()}catch(t){console.warn("lightGallery:- make sure lightGallery module is properly initiated")}}))},w.prototype.destroyModules=function(t){this.plugins.forEach((function(e){try{t?e.destroy():e.closeGallery&&e.closeGallery()}catch(t){console.warn("lightGallery:- make sure lightGallery module is properly destroyed")}}))},w.prototype.refresh=function(t){this.settings.dynamic||this.invalidateItems(),this.galleryItems=t||this.getItems(),this.updateControls(),this.openGalleryOnItemClick(),this.LGel.trigger(o)},w.prototype.updateControls=function(){this.addSlideVideoInfo(this.galleryItems),this.updateCounterTotal(),this.manageSingleSlideClassName()},w.prototype.destroyGallery=function(){this.destroyModules(!0),this.settings.dynamic||this.invalidateItems(),x(window).off(".lg.global"+this.lgId),this.LGel.off(".lg"),this.$container.remove()},w.prototype.destroy=function(){var t=this.closeGallery(!0);return t?setTimeout(this.destroyGallery.bind(this),t):this.destroyGallery(),t},w}();return function(t,e){return new H(t,e)}}));
//# sourceMappingURL=/sm/70289cae91925bae99cbba52913646ad08c30e3fef6435dbc2a7586d5b95f331.map

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + "chat" + ".min.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		// data-webpack is not used as build has no uniqueName
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 		
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			414: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

;// ./public/js/core/event-bus.js
const Events = Object.freeze({
    PAGE_LOADED:                'page:loaded',
    MODAL_LOADED:               'modal:loaded',
    DARK_MODE_TOGGLED:          'darkMode:toggled',
    FULLSCREEN_ENABLED:         'fullscreen:enabled',
    TAB_CHANGED:                'tab:changed',
    SIDEBAR_RESIZED:            'sidebar:resized',
    NAVIGATION_CLICKED:         'navigation:clicked',
    DATA_TABLE_CLUSTER_CHANGED: 'dataTable:clusterChanged',
});

class EventBus {
    constructor() {
        this._listeners = {};
    }

    on(event, handler) {
        if (!this._listeners[event]) {
            this._listeners[event] = [];
        }
        this._listeners[event].push(handler);
        return this;
    }

    off(event, handler) {
        if (!this._listeners[event]) return this;
        this._listeners[event] = this._listeners[event].filter(h => h !== handler);
        return this;
    }

    emit(event, detail = {}) {
        if (!this._listeners[event]) return this;
        for (const handler of this._listeners[event]) {
            handler(detail);
        }
        return this;
    }
}

const eventBus = new EventBus();

;// ./public/js/features/data-table/storage.js
const FilterName = Object.freeze({
    ACTIVITIES: 'activities',
    SEGMENTS: 'segments',
    PHOTO_WALL: 'photoWall',
    HEATMAP: 'heatmap',
});

class FilterStorage {
    static storageKey = 'filters';

    static clearAll(tableName) {
        FilterStorage.set(tableName, {});
    }

    static get(tableName) {
        const storedJson = localStorage.getItem(FilterStorage.storageKey);
        if (!storedJson) return {};
        const parsed = JSON.parse(storedJson);
        return parsed[tableName] || {};
    }

    static set(tableName, object) {
        const storedJson = localStorage.getItem(FilterStorage.storageKey);
        const existing = storedJson ? JSON.parse(storedJson) : {};
        existing[tableName] = object;
        localStorage.setItem(FilterStorage.storageKey, JSON.stringify(existing));
    }
}

;// ./public/js/core/router.js


class Router {
    constructor(app) {
        this.app = app;
        this.appContent = app.querySelector('#js-loaded-content');
        this.spinner = app.querySelector('#spinner');
        this.menu = document.querySelector('aside');
        this.menuItems = document.querySelectorAll(
            'nav a[data-router-navigate]:not([data-router-disabled]), aside li a[data-router-navigate]:not([data-router-disabled])'
        );
        this.mobileNavTriggerEl = document.querySelector('[data-drawer-target="drawer-navigation"]');
    }

    showLoader() {
        this.spinner.classList.remove('hidden');
        this.spinner.classList.add('flex');
        this.appContent.classList.add('hidden');
    }

    hideLoader() {
        this.spinner.classList.remove('flex');
        this.spinner.classList.add('hidden');
        this.appContent.classList.remove('hidden');
    }

    determineActiveMenuLink(url) {
        const activeLink = document.querySelector(`aside li a[data-router-navigate="${url}"]`);
        if (activeLink) {
            return activeLink;
        }

        const newUrl = url.replace(/\/[^\/]*$/, '');
        if (newUrl === url || newUrl === '') {
            return null;
        }

        return this.determineActiveMenuLink(newUrl);
    }

    async renderContent(page, modalId) {
        // Close mobile nav if open
        if (!this.menu.hasAttribute('aria-hidden')) {
            this.mobileNavTriggerEl.dispatchEvent(
                new MouseEvent('click', {bubbles: true, cancelable: true, view: window})
            );
        }

        this.showLoader();

        const response = await fetch(`${page}.html`, {cache: 'no-store'});
        this.appContent.innerHTML = await response.text();
        window.scrollTo(0, 0);

        this.hideLoader();

        this.app.setAttribute('data-router-current', page);
        this.app.setAttribute('data-modal-current', modalId);

        // Update active states
        this.menuItems.forEach(node => node.setAttribute('aria-selected', 'false'));

        const activeLink = this.determineActiveMenuLink(page);
        activeLink?.setAttribute('aria-selected', 'true');

        if (activeLink?.hasAttribute('data-router-sub-menu')) {
            activeLink.closest('ul')?.classList.remove('hidden');
        }

        // Re-register nav items that may have been added dynamically
        const newNavItems = document.querySelectorAll('main a[data-router-navigate]:not([data-router-disabled])');
        this.registerNavItems(newNavItems);

        const fullPageName = page
            .replace(window.statisticsForStrava.appUrl.basePath, '')
            .replace(/^\/+/, '')
            .replaceAll('/', '-');

        eventBus.emit(Events.PAGE_LOADED, {page: fullPageName, modalId});
    }

    registerNavItems(items) {
        items.forEach(link => {
            link.addEventListener('click', e => {
                e.preventDefault();
                const route = link.getAttribute('data-router-navigate');

                eventBus.emit(Events.NAVIGATION_CLICKED, {link});

                this.navigateTo(
                    route,
                    null,
                    link.hasAttribute('data-router-force-reload')
                );
            });
        });
    }

    registerBrowserBackAndForth() {
        window.onpopstate = e => {
            if (!e.state) return;
            this.renderContent(e.state.route, e.state.modal);
        };
    }

    navigateTo(route, modal, force = false) {
        const currentRoute = this.app.getAttribute('data-router-current');
        if (currentRoute === route && !force) return; // Avoid reloading same page.

        this.renderContent(route, modal);
        this.pushRouteToHistoryState(route, modal);
    }

    pushRouteToHistoryState(route, modal) {
        const fullRoute = modal ? `${route}#${modal}` : route;
        window.history.pushState({route, modal}, '', fullRoute);
    }

    pushCurrentRouteToHistoryState(modal) {
        this.pushRouteToHistoryState(this.currentRoute(), modal);
    }

    currentRoute() {
        const defaultRoute = '/dashboard';
        if (window.statisticsForStrava.appUrl.basePath === '') {
            // App is not served from a subpath.
            return location.pathname.replace('/', '') ? location.pathname : defaultRoute;
        }

        // App is served from a subpath.
        const base = '/' + window.statisticsForStrava.appUrl.basePath.replace(/^\/+|\/+$/g, '');
        const pathname = location.pathname.replace(/\/+$/, '');

        return pathname === base
            ? base + defaultRoute
            : location.pathname;
    }

    boot() {
        if (this.appContent === null) {
            // App content can be null if SYMFONY routing is used.
            return;
        }

        const route = this.currentRoute();
        const modal = location.hash.replace('#', '');

        this.registerNavItems(this.menuItems);
        this.registerBrowserBackAndForth();
        this.renderContent(route, modal);

        window.history.replaceState({route, modal}, '', route + location.hash);
    }
}

;// ./public/js/services/github.js
const compareVersions = (a, b) => {
    a = a.replace(/^v/, '');
    b = b.replace(/^v/, '');

    const pa = a.split('.').map(Number);
    const pb = b.split('.').map(Number);

    for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
        const na = pa[i] || 0;
        const nb = pb[i] || 0;
        if (na > nb) return 1;
        if (na < nb) return -1;
    }
    return 0;
}

const showLatestVersion = (latestVersion) => {
    const $latestVersionEl = document.querySelector('[data-latest-version]');
    const $link = $latestVersionEl.querySelector('a');
    if ($link) {
        $link.href = $link.href.replace('[LATEST_VERSION]', latestVersion);
        $link.textContent = $link.textContent.replace('[LATEST_VERSION]', latestVersion);
    }
    $latestVersionEl.classList.remove('hidden');
};

const updateGithubLatestRelease = async () => {
    const $latestVersionEl = document.querySelector('[data-latest-version]');
    if (!$latestVersionEl) return;

    const currentVersion = $latestVersionEl.dataset.currentVersion;
    if (!currentVersion) return;

    const CACHE_KEY = 'latestReleaseCache';
    const CACHE_TTL = 1000 * 60 * 60 * 6; // 6 hours

    const now = Date.now();
    const cached = JSON.parse(localStorage.getItem(CACHE_KEY) || 'null');

    // If cache exists and is recent, use it
    if (cached && now - cached.timestamp < CACHE_TTL) {
        if (compareVersions(currentVersion, cached.latestVersion) < 0) {
            // Update available.
            showLatestVersion(cached.latestVersion);
        }
        return;
    }

    try {
        const releaseResponse = await fetch(
            'https://api.github.com/repos/robiningelbrecht/statistics-for-strava/releases/latest',
            { headers: { 'Accept': 'application/vnd.github+json' } }
        );
        if (!releaseResponse.ok) throw new Error('Failed to fetch latest release');

        const latestVersion = (await releaseResponse.json()).name;

        if (currentVersion === latestVersion) {
            localStorage.setItem(CACHE_KEY, JSON.stringify({ latestVersion, timestamp: now }));
            return;
        }

        // Verify Docker image workflow run success
        const workflowRunsResponse = await fetch(
            `https://api.github.com/repos/robiningelbrecht/statistics-for-strava/actions/runs?event=push&status=completed&conclusion=success&exclude_pull_requests=true&branch=${latestVersion}`,
            { headers: { 'Accept': 'application/vnd.github+json' } }
        );
        if (!workflowRunsResponse.ok) throw new Error('Failed to fetch workflow runs');

        const { workflow_runs = [] } = await workflowRunsResponse.json();
        const dockerWorkflowRun = workflow_runs.find(
            run => run.path === '.github/workflows/docker-image.yml'
        );

        if(!dockerWorkflowRun) return;

        showLatestVersion(latestVersion);
        localStorage.setItem(CACHE_KEY, JSON.stringify({ latestVersion, timestamp: now }));
    } catch (err) {
        console.error('Error checking latest release:', err);
    }
}
;// ./public/js/components/sidebar.js


class Sidebar {
    init() {
        document.getElementById('toggle-sidebar-collapsed-state').addEventListener('click', () => {
            const collapsed = document.documentElement.toggleAttribute('data-sidebar-collapsed');
            localStorage.setItem('sideNavCollapsed', String(collapsed));
            eventBus.emit(Events.SIDEBAR_RESIZED);
        });
    }
}
;// ./public/js/utils.js
const debounce = (func, timeout = 300) => {
    let timer;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            func.apply(undefined, args);
        }, timeout);
    };
}
const numberFormat = (number, decimals, decPoint, thousandsSep) => {
    number = (number + '').replace(/[^0-9+\-Ee.]/g, '')
    const n = !isFinite(+number) ? 0 : +number
    const prec = !isFinite(+decimals) ? 0 : Math.abs(decimals)
    const sep = typeof thousandsSep === 'undefined' ? ',' : thousandsSep
    const dec = typeof decPoint === 'undefined' ? '.' : decPoint
    let s = ''

    const toFixedFix = function (n, prec) {
        if (('' + n).indexOf('e') === -1) {
            return +(Math.round(n + 'e+' + prec) + 'e-' + prec)
        } else {
            const arr = ('' + n).split('e')
            let sig = ''
            if (+arr[1] + prec > 0) {
                sig = '+'
            }
            return (+(Math.round(+arr[0] + 'e' + sig + (+arr[1] + prec)) + 'e-' + prec)).toFixed(prec)
        }
    }

    // @todo: for IE parseFloat(0.55).toFixed(0) = 0;
    s = (prec ? toFixedFix(n, prec).toString() : '' + Math.round(n)).split('.')
    if (s[0].length > 3) {
        s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
    }
    if ((s[1] || '').length < prec) {
        s[1] = s[1] || ''
        s[1] += new Array(prec - s[1].length + 1).join('0')
    }

    return s.join(dec)
}

const resolveEchartsCallbacks = (obj, path) => {
    const parts = path.split('.');

    const resolvePath = (currentObj, remainingParts) => {
        if (!currentObj || remainingParts.length === 0) return;

        const key = remainingParts[0];
        const rest = remainingParts.slice(1);

        const isArrayKey = key.endsWith('[]');
        const rawKey = isArrayKey ? key.slice(0, -2) : key;

        if (isArrayKey) {
            const arr = currentObj?.[rawKey];
            if (Array.isArray(arr)) {
                arr.forEach(item => resolvePath(item, rest));
            }
        } else if (rest.length === 0) {
            // final key, do callback replacement
            if (
                currentObj?.[rawKey] &&
                currentObj[rawKey] in window.statisticsForStrava.callbacks
            ) {
                currentObj[rawKey] = window.statisticsForStrava.callbacks[currentObj[rawKey]];
            }
        } else {
            resolvePath(currentObj?.[rawKey], rest);
        }
    };

    resolvePath(obj, parts);
};

const fetchJson = async (url) => {
    const response = await fetch(url);

    if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.status}`);
    }

    return response.json();
}

const parents = (el, selector) => {
    const matched = [];
    let parent = el.parentElement;

    while (parent) {
        if (!selector || parent.matches(selector)) {
            matched.push(parent);
        }
        parent = parent.parentElement;
    }

    return matched;
}


;// ./public/js/features/charts/echarts-themes.js
const v5Theme = () => {
    const backgroundColor = 'transparent';
    const gradientColor = ['#f6efa6', '#d88273', '#bf444c'];

    const axisCommon = function () {
        return {
            axisLine: {
                lineStyle: {
                    color: '#6E7079'
                }
            },
            axisLabel: {
                color: null
            },
            splitLine: {
                lineStyle: {
                    color: ['#E0E6F1']
                }
            },
            splitArea: {
                areaStyle: {
                    color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']
                }
            },
            minorSplitLine: {
                color: '#F4F7FD'
            }
        };
    };

    return {
        backgroundColor: backgroundColor,
        color: [
            '#5470c6',
            '#91cc75',
            '#fac858',
            '#ee6666',
            '#73c0de',
            '#3ba272',
            '#fc8452',
            '#9a60b4',
            '#ea7ccc'
        ],
        gradientColor: gradientColor,
        loading: {
            textColor: 'red'
        },
        bar: {
            defaultBarGap: '20%',
            select: {
                itemStyle: {
                    borderColor: '#212121',
                    borderWidth: 1
                }
            }
        },
        boxplot: {
            emphasis: {
                itemStyle: {
                    shadowColor: 'rgba(0,0,0,0.2)'
                }
            }
        },
        graph: {
            lineStyle: {
                color: '#aaa'
            },
            select: {
                itemStyle: {
                    borderColor: '#212121'
                }
            }
        },
        heatmap: {
            select: {
                itemStyle: {
                    borderColor: '#212121'
                }
            }
        },
        line: {
            symbolSize: 4
        },
        pictorialBar: {
            select: {
                itemStyle: {
                    borderColor: '#212121',
                    borderWidth: 1
                }
            }
        },
        pie: {
            radius: [0, '75%'],
            labelLine: {
                length2: 15
            }
        },
        map: {
            defaultItemStyleColor: '#eee',
            label: {
                color: '#000'
            },
            itemStyle: {
                borderColor: '#444',
                areaColor: '#eee'
            },
            emphasis: {
                label: {
                    color: 'rgb(100,0,0)'
                },
                itemStyle: {
                    areaColor: 'rgba(255,215,0,0.8)'
                }
            },
            select: {
                label: {
                    color: 'rgb(100,0,0)'
                },
                itemStyle: {
                    color: 'rgba(255,215,0,0.8)'
                }
            },
        },
        timeAxis: axisCommon(),
        logAxis: axisCommon(),
        valueAxis: axisCommon(),
        categoryAxis: (() => {
            const axis = axisCommon();
            axis.axisTick = {
                show: true
            };
            return axis;
        })(),
        axisPointer: {
            lineStyle: {
                color: '#B9BEC9'
            },
            shadowStyle: {
                color: 'rgba(210,219,238,0.2)'
            },
            label: {
                backgroundColor: 'auto',
                color: '#fff'
            },
            handle: {
                color: '#333',
                shadowBlur: 3,
                shadowColor: '#aaa',
                shadowOffsetX: 0,
                shadowOffsetY: 2,
            }
        },
        brush: {
            brushStyle: {
                color: 'rgba(210,219,238,0.3)',
                borderColor: '#D2DBEE'
            },
            defaultOutOfBrushColor: '#ddd'
        },
        calendar: {
            splitLine: {
                lineStyle: {
                    color: '#000'
                }
            },
            itemStyle: {
                borderColor: '#ccc'
            },
            dayLabel: {
                margin: '50%',
                color: '#000'
            },
            monthLabel: {
                margin: 5,
                color: '#000'
            },
            yearLabel: {
                margin: 30,
                color: '#ccc'
            }
        },
        dataZoom: {
            borderColor: '#d2dbee',
            borderRadius: 3,
            backgroundColor: 'rgba(47,69,84,0)',
            dataBackground: {
                lineStyle: {
                    color: '#d2dbee',
                    width: 0.5
                },
                areaStyle: {
                    color: '#d2dbee',
                    opacity: 0.2
                }
            },
            selectedDataBackground: {
                lineStyle: {
                    color: '#8fb0f7',
                    width: 0.5
                },
                areaStyle: {
                    color: '#8fb0f7',
                    opacity: 0.2
                }
            },
            handleStyle: {
                color: '#fff',
                borderColor: '#ACB8D1'
            },
            moveHandleStyle: {
                color: '#D2DBEE',
                opacity: 0.7
            },
            textStyle: {
                color: '#6E7079'
            },
            brushStyle: {
                color: 'rgba(135,175,274,0.15)'
            },
            emphasis: {
                handleStyle: {
                    borderColor: '#8FB0F7'
                },
                moveHandleStyle: {
                    color: '#8FB0F7',
                    opacity: 0.7
                }
            },
            defaultLocationEdgeGap: 7
        },
        geo: {
            defaultItemStyleColor: '#eee',
            label: {
                color: '#000'
            },
            itemStyle: {
                borderColor: '#444'
            },
            emphasis: {
                label: {
                    color: 'rgb(100,0,0)'
                },
                itemStyle: {
                    color: 'rgba(255,215,0,0.8)'
                }
            },
            select: {
                label: {
                    color: 'rgb(100,0,0)'
                },
                itemStyle: {
                    color: 'rgba(255,215,0,0.8)'
                }
            }
        },
        grid: {
            left: '10%',
            top: 60,
            bottom: 70,
            borderColor: '#ccc'
        },
        legend: {
            top: 0,
            bottom: null,
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',
            itemGap: 10,
            inactiveColor: '#ccc',
            inactiveBorderColor: '#ccc',
            lineStyle: {
                inactiveColor: '#ccc',
            },
            textStyle: {
                color: '#333'
            },
            selectorLabel: {
                color: '#666',
                borderColor: '#666'
            },
            emphasis: {
                selectorLabel: {
                    color: '#eee',
                    backgroundColor: '#666'
                }
            },
            pageIconColor: '#2f4554',
            pageIconInactiveColor: '#aaa',
            pageTextStyle: {
                color: '#333'
            }
        },
        title: {
            left: 0,
            top: 0,
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',
            textStyle: {
                color: '#464646'
            },
            subtextStyle: {
                color: '#6E7079'
            }
        },
        toolbox: {
            borderColor: '#ccc',
            padding: 5,
            itemGap: 8,
            iconStyle: {
                borderColor: '#666',
            },
            emphasis: {
                iconStyle: {
                    borderColor: '#3E98C5'
                }
            }
        },
        tooltip: {
            axisPointer: {
                crossStyle: {
                    color: '#999'
                }
            },
            textStyle: {
                color: '#666'
            },
            backgroundColor: '#fff',
            borderWidth: 1,
            defaultBorderColor: '#fff'
        },
        visualMap: {
            color: [gradientColor[2], gradientColor[1], gradientColor[0]],
            inactive: ['rgba(0,0,0,0)'],
            indicatorStyle: {
                shadowColor: 'rgba(0,0,0,0.2)'
            },
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc',
            contentColor: '#5793f3',
            inactiveColor: '#aaa',
            padding: 5,
            textStyle: {
                color: '#333'
            }
        }
    };
}

const v5DarkTheme = () => {
    const base = v5Theme();
    const backgroundColor = 'transparent';
    const contrastColor = '#B9B8CE';

    const axisCommon = function () {
        return {
            axisLine: {
                lineStyle: {
                    color: contrastColor
                }
            },
            splitLine: {
                lineStyle: {
                    color: '#484753'
                }
            },
            splitArea: {
                areaStyle: {
                    color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']
                }
            },
            minorSplitLine: {
                lineStyle: {
                    color: '#20203B'
                }
            }
        };
    };

    // Dark overrides
    const overrides = {
        darkMode: true,
        backgroundColor: backgroundColor,
        loading: {
            textColor: '#c9d1d9'
        },
        axisPointer: {
            ...base.axisPointer,
            lineStyle: {
                color: '#817f91'
            },
            crossStyle: {
                color: '#817f91'
            },
            label: {
                color: '#fff'
            }
        },
        legend: {
            ...base.legend,
            textStyle: {
                color: contrastColor
            }
        },
        textStyle: {
            ...base.textStyle,
            color: contrastColor
        },
        title: {
            ...base.title,
            textStyle: {
                color: '#EEF1FA'
            },
            subtextStyle: {
                color: '#B9B8CE'
            }
        },
        toolbox: {
            ...base.toolbox,
            iconStyle: {
                borderColor: contrastColor
            }
        },
        tooltip: {
            backgroundColor: '#2a313c',
            borderColor: '#3d444d',
            textStyle: { color: '#f0f6fc' }
        },
        timeAxis: axisCommon(),
        logAxis: axisCommon(),
        valueAxis: axisCommon(),
        categoryAxis: (() => {
            const axis = axisCommon();
            axis.axisTick = {
                show: true
            };
            return axis;
        })(),
        grid: {
            ...base.grid,
            borderColor: '#3d444d'
        },
        visualMap: {
            ...base.visualMap,
            textStyle: {
                color: contrastColor
            }
        },
        calendar: {
            ...base.calendar,
            itemStyle: {
                color: backgroundColor
            },
            dayLabel: {
                color: contrastColor
            },
            monthLabel: {
                color: contrastColor
            },
            yearLabel: {
                color: contrastColor
            }
        },
        dataZoom: {
            ...base.dataZoom,
            borderColor: '#3d444d',
            backgroundColor: 'rgba(33,40,48,0)',
            handleStyle: { color: '#c9d1d9', borderColor: '#656c76' },
            textStyle: { color: '#c9d1d9' },
            selectedDataBackground: { areaStyle: { color: '#539bf520', opacity: 0.2 } }
        }
    };

    return { ...base, ...overrides };
};



;// ./public/js/features/charts/chart-manager.js




class ChartManager {
    constructor(router, modalManager) {
        this.router = router;
        this.modalManager = modalManager;
        this.allCharts = [];
        this.chartsPerTab = [];

        echarts.registerTheme('v5', v5Theme());
        echarts.registerTheme('v5-dark', v5DarkTheme());
    }

    init(rootNode, isDarkMode) {
        const handlers = this.getClickHandlers();
        const connectedCharts = [];
        rootNode.querySelectorAll('[data-echarts-options]').forEach(chartNode => {
            const chart = echarts.init(chartNode, isDarkMode ? 'v5-dark' : 'v5');
            const rawChartOptions = chartNode.getAttribute('data-echarts-options');

            const loadOptions = rawChartOptions.toLowerCase().endsWith('.json')
                ? fetchJson(rawChartOptions)
                : Promise.resolve(JSON.parse(rawChartOptions));
            chart.showLoading();

            loadOptions.then(chartOptions => {
                [
                    'tooltip.formatter',
                    'tooltip.valueFormatter',
                    'yAxis.axisLabel.formatter',
                    'yAxis[].axisLabel.formatter',
                    'series.symbolSize',
                    'dataZoom[].labelFormatter'
                ].forEach(path => resolveEchartsCallbacks(chartOptions, path));
                chart.setOption(chartOptions);
            })
                .catch(error => {
                    console.error('Failed to load chart data:', error);
                })
                .finally(() => {
                    chart.hideLoading();
                });

            const clickHandlerName = chartNode.getAttribute('data-echarts-click');
            if (clickHandlerName && handlers[clickHandlerName]) {
                chart.on('click', function (params) {
                    const clickData = JSON.parse(chartNode.getAttribute('data-echarts-click-data') || '{}');
                    handlers[clickHandlerName](params, clickData);
                });
            }
            if (chartNode.hasAttribute('data-echarts-connect')) {
                connectedCharts.push(chart);
            }

            this.allCharts.push(chart);

            const tabPanels = parents(chartNode, 'div[role="tabpanel"]');
            for (const tabPanel of tabPanels) {
                const tabPanelId = tabPanel.getAttribute('id');
                this.chartsPerTab[tabPanelId] ??= [];
                this.chartsPerTab[tabPanelId].push(chart);
            }

        });
        echarts.connect(connectedCharts);
    }

    getClickHandlers() {
        return {
            handleMonthlyStatsClick: (params, clickData) => {
                if (!params || !params.dataIndex || !params.seriesName) {
                    return;
                }
                const month = (params.dataIndex + 1).toString().padStart(2, "0");
                const modalId = `month/month-${params.seriesName}-${month}.html`;

                this.modalManager.open(modalId);
                this.router.pushCurrentRouteToHistoryState(modalId);
            },
            handleWeeklyStatsClick: (params, clickData) => {
                if (!params || !params.dataIndex) {
                    return;
                }

                const weeks = clickData.weeks;
                if (!params.dataIndex in weeks) {
                    return;
                }
                FilterStorage.set(FilterName.ACTIVITIES, {
                    "sportType": clickData.sportTypes,
                    "start-date": {"from": weeks[params.dataIndex]['from'], "to": weeks[params.dataIndex]['to']},
                });

                this.router.navigateTo(`/activities`);
            },
            handleActivityGridChartClick: (params, clickData) => {
                if (!params || !params.value || params.value < 1) {
                    return;
                }

                FilterStorage.set(FilterName.ACTIVITIES, {
                    "start-date": {"from": params.value[0], "to": params.value[0]},
                });

                this.router.navigateTo(`/activities`);
            },
        };
    }

    reset() {
        this.allCharts = [];
        this.chartsPerTab = [];
    }

    resizeAll() {
        this.allCharts
            .filter(chart => chart.getDom().offsetParent)
            .forEach(chart => chart.resize());
    }

    toggleDarkTheme(isDarkMode) {
        this.allCharts
            .filter(chart => chart.getDom().offsetParent)
            .forEach(chart => chart.setTheme(isDarkMode ? 'v5-dark' : 'v5'));
    }

    resizeInTab(tabId) {
        if (tabId in this.chartsPerTab) {
            this.chartsPerTab[tabId]
                .filter(chart => chart.getDom().offsetParent)
                .forEach((chart) => chart.resize());
        }
    }
}

;// ./public/js/components/modals.js


class ModalManager {
    constructor(router) {
        this.router = router;
        this.modalSkeletonNode = document.getElementById('modal-skeleton');
        this.modalContent = this.modalSkeletonNode.querySelector('#modal-content');
        this.modalSpinner = this.modalSkeletonNode.querySelector('.spinner');
        this.modal = null;
    }

    init(rootNode) {
        const modalLinks = rootNode.querySelectorAll('a[data-model-content-url]');

        modalLinks.forEach(node => {
            node.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const modalId = node.getAttribute('data-model-content-url');
                this.open(modalId);
                // Add modal to history state.
                this.router.pushCurrentRouteToHistoryState(modalId);
            });
        });
    }

    open(modalId) {
        this.close();

        // Show loading state.
        this.modalSpinner.classList.remove('hidden');
        this.modalSpinner.classList.add('flex');

        this.modal = new Modal(this.modalSkeletonNode, {
            placement: 'bottom',
            closable: true,
            backdropClasses: 'bg-gray-900/50 fixed inset-0 z-1400',
            onShow: async () => {
                const response = await fetch(modalId, {cache: 'no-store'});
                // Remove loading state.
                this.modalSpinner.classList.add('hidden');
                this.modalSpinner.classList.remove('flex');

                this.modalContent.innerHTML = await response.text();
                const modalName = modalId.replace(/^\/+/, '').replaceAll('/', '-');
                eventBus.emit(Events.MODAL_LOADED, {node: this.modalSkeletonNode, modalName});
                // Modal close event listeners.
                const closeButton = this.modalContent.querySelector('button.close');
                if (closeButton) {
                    this.modalContent.querySelector('button.close').addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.modal.hide();
                        this.router.pushCurrentRouteToHistoryState();
                    });
                }

                document.body.addEventListener('keydown', (e) => {
                    if (e.key !== 'Escape') {
                        return;
                    }
                    this.router.pushCurrentRouteToHistoryState();
                }, {once: true});

                document.body.addEventListener('click', (e) => {
                    if (e.target.id !== 'modal-skeleton') {
                        return;
                    }
                    this.router.pushCurrentRouteToHistoryState();
                }, {once: true});

                // Re-register nav items that may have been added dynamically
                const newNavItems = this.modalSkeletonNode.querySelectorAll('a[data-router-navigate]:not([data-router-disabled])');
                this.router.registerNavItems(newNavItems);
            },
            onHide: () => {
                this.modalContent.innerHTML = '';
            }
        });

        this.modal.show();
    }

    close() {
        if (!this.modal) {
            return;
        }

        this.modal.hide();
    }
}
;// ./public/js/features/data-table/filter-manager.js


class FilterManager {
    constructor(wrapper) {
        this.wrapper = wrapper;
        this.filters = {};
    }

    _isRangeFilter(value) {
        return typeof value === 'object' && value !== null && 'from' in value && 'to' in value;
    }

    prefillFromStorage(tableName) {
        const stored = FilterStorage.get(tableName);
        if (!stored) return;

        Object.keys(stored).forEach(key => {
            if (this._isRangeFilter(stored[key])) {
                return;
            }
            const value = stored[key];

            this.wrapper.querySelectorAll(`input[data-dataTable-filter="${key}"]`).forEach(input => {
                const inputValue = input.value.toLowerCase();

                if (Array.isArray(value)) {
                    // Multiple checkbox values.
                    if (value.filter(v => v !== null).map(v => v.toLowerCase()).includes(inputValue)) {
                        input.checked = true;
                    }
                } else if (value !== null && inputValue === value.toLowerCase()) {
                    input.checked = true;
                }
            });
        });

        // Handle range filters (date and number).
        Object.entries(stored)
            .filter(([_, v]) => this._isRangeFilter(v))
            .forEach(([name, range]) => {
                const from = this.wrapper.querySelector(`input[name="${name}[from]"]`);
                const to = this.wrapper.querySelector(`input[name="${name}[to]"]`);

                if (from?.type === 'date') {
                    if (from && range.from) from.valueAsDate = new Date(range.from);
                    if (to && range.to) to.valueAsDate = new Date(range.to);
                } else if (from?.type === 'number') {
                    const multiplier = range.multiplier || 1;
                    if (from && range.from != null) from.value = range.from / multiplier;
                    if (to && range.to != null) to.value = range.to / multiplier;
                }
            });
    }

    getActiveFilters() {
        const filters = {};

        this.wrapper.querySelectorAll('[data-dataTable-filter]:checked').forEach(el => {
            const key = el.getAttribute('data-dataTable-filter');
            const value = el.value.toLowerCase();

            if (filters[key]) {
                if (Array.isArray(filters[key])) {
                    filters[key].push(value);
                } else {
                    filters[key] = [filters[key], value];
                }
            } else {
                filters[key] = value;
            }
        });

        this.wrapper.querySelectorAll('[data-dataTable-filter*="[]"]').forEach(group => {
            const name = group.getAttribute('data-dataTable-filter').replace('[]', '');
            const from = group.querySelector(`input[name="${name}[from]"]`);
            const to = group.querySelector(`input[name="${name}[to]"]`);
            if (!from || !to) return;

            if (from.type === 'date') {
                const fromMs = from.valueAsDate ? new Date(from.valueAsNumber).setUTCHours(0, 0, 0) : null;
                const toMs = to.valueAsDate ? new Date(to.valueAsNumber).setUTCHours(23, 59, 59) : null;
                if (fromMs !== null || toMs !== null) {
                    filters[name] = { from: fromMs, to: toMs };
                }
            } else if (from.type === 'number') {
                const fromVal = from.value !== '' ? parseFloat(from.value) : null;
                const toVal = to.value !== '' ? parseFloat(to.value) : null;
                if (fromVal !== null || toVal !== null) {
                    const step = Math.min(
                        parseFloat(from.step) || 1,
                        parseFloat(to.step) || 1
                    );
                    const multiplier = Math.round(1 / step);
                    filters[name] = {
                        from: fromVal !== null ? Math.round(fromVal * multiplier) : null,
                        to: toVal !== null ? Math.round(toVal * multiplier) : null,
                        multiplier: multiplier,
                    };
                }
            }
        });

        return filters;
    }

    updateDropdownState(activeFilters) {
        this.wrapper.querySelectorAll('.filter-dropdown [data-dropdown-toggle]').forEach(el => {
            el.classList.remove('active');
        });

        Object.entries(activeFilters).forEach(([key, activeFilter]) => {
            if (this._isRangeFilter(activeFilter)) {
                const dropdown = this.wrapper
                    .querySelector(`[data-datatable-filter="${key}[]"]`)
                    ?.closest('.filter-dropdown');

                const toggle = dropdown?.querySelector('[data-dropdown-toggle]');
                if (toggle) toggle.classList.add('active');
                return;
            }

            const dropdown = this.wrapper.querySelector(`[data-dataTable-filter="${key}"]:checked`)?.closest('.filter-dropdown');
            const toggle = dropdown?.querySelector('[data-dropdown-toggle]');
            if (toggle) toggle.classList.add('active');
        });
    }

    applyFiltersToRows(rows, search = '') {
        const filters = this.getActiveFilters();
        const searchLower = search.toLowerCase();

        rows.forEach(row => {
            row.active = !row.searchables || row.searchables.toLowerCase().includes(searchLower);

            for (const [key, activeFilter] of Object.entries(filters)) {
                const filterValue = row.filterables[key];

                if (this._isRangeFilter(activeFilter)) {
                    if (activeFilter.from !== null && activeFilter.to !== null) {
                        row.active = row.active && filterValue >= activeFilter.from && filterValue <= activeFilter.to;
                    } else if (activeFilter.from !== null) {
                        row.active = row.active && filterValue >= activeFilter.from;
                    } else if (activeFilter.to !== null) {
                        row.active = row.active && filterValue <= activeFilter.to;
                    }
                    continue;
                }

                // Multi-checkbox filter.
                if (Array.isArray(activeFilter)) {
                    row.active = row.active && activeFilter.includes(filterValue?.toLowerCase());
                    continue;
                }

                // Single radio or text filter.
                row.active = row.active &&
                    (
                        Array.isArray(filterValue)
                            ? filterValue.map(v => v.toLowerCase()).includes(activeFilter)
                            : filterValue?.toLowerCase() === activeFilter
                    );
            }
        });
        return rows;
    }

    resetAll(tableName) {
        const elements = this.wrapper.querySelectorAll('[data-dataTable-filter], [data-dataTable-filter*="[]"] input');
        elements.forEach(el => {
            if (el.type === 'radio' || el.type === 'checkbox') {
                el.checked = false;
            } else {
                el.value = '';
            }
        });
        FilterStorage.clearAll(tableName);
    }

    resetOne(name) {
        this.wrapper.querySelectorAll(`[data-dataTable-filter][name^="${name}"], [data-dataTable-filter*="[]"] [name^="${name}"]`).forEach(el => {
            if (el.type === 'radio' || el.type === 'checkbox') {
                el.checked = false;
            } else {
                el.value = '';
            }
        });
    }

    updateStorage(tableName, activeFilters) {
        FilterStorage.set(tableName, activeFilters);
    }
}

// EXTERNAL MODULE: ./public/libraries/lightgallery/lightgallery.umd.min.js
var lightgallery_umd_min = __webpack_require__(360);
var lightgallery_umd_min_default = /*#__PURE__*/__webpack_require__.n(lightgallery_umd_min);
// EXTERNAL MODULE: ./public/libraries/lightgallery/lightgallery.lg-zoom.min.js
var lightgallery_lg_zoom_min = __webpack_require__(569);
var lightgallery_lg_zoom_min_default = /*#__PURE__*/__webpack_require__.n(lightgallery_lg_zoom_min);
// EXTERNAL MODULE: ./public/libraries/lightgallery/lightgallery.lg-fullscreen.min.js
var lightgallery_lg_fullscreen_min = __webpack_require__(563);
var lightgallery_lg_fullscreen_min_default = /*#__PURE__*/__webpack_require__.n(lightgallery_lg_fullscreen_min);
;// ./public/js/features/photos/light-gallery.js




class LightGallery {
    constructor(wrapper) {
        this.trigger = wrapper.querySelector('[data-light-gallery-trigger]');
        this.gallery = lightgallery_umd_min_default()(this.trigger, {
            dynamic: true,
            plugins: [(lightgallery_lg_zoom_min_default()), (lightgallery_lg_fullscreen_min_default())],
            backdropDuration: 200,
            dynamicEl: [],
        });
    }

    refresh(activeImages) {
        const items = activeImages.map(img =>
            JSON.parse(img.element.getAttribute('data-light-gallery-element'))
        );
        this.gallery.refresh(items);
    }

    bindEvents() {
        this.trigger?.addEventListener('click', () => this.gallery.openGallery());
    }
}

;// ./public/js/features/photos/photo-wall.js




class PhotoWall {
    constructor(wrapper) {
        this.wrapper = wrapper;
        this.resetBtn = wrapper.querySelector('[data-dataTable-reset]');
        this.filterManager = new FilterManager(wrapper);
        this.allImages = Array.from(this.wrapper.querySelectorAll('[data-image]')).map(el => ({
            element: el,
            filterables: JSON.parse(el.getAttribute('data-filterables')),
            active: true
        }));
        this.lightGallery = new LightGallery(this.wrapper);
    }

    async render() {
        const redraw = () => {
            const activeFilters = this.filterManager.getActiveFilters();
            this.filterManager.updateDropdownState(activeFilters);

            const images = this.filterManager.applyFiltersToRows(this.allImages);
            for (const {element, active} of images) {
                element.classList.toggle('hidden', !active);
            }

            this.resetBtn.classList.toggle('hidden', !(Object.keys(activeFilters).length > 0));

            const activeImages = images.filter((image) => image.active);
            const resultCount = this.wrapper.querySelector('[data-dataTable-result-count]');
            if (resultCount) resultCount.innerText = activeImages.length;

            this.lightGallery.refresh(activeImages);
        };

        FilterStorage.set(FilterName.PHOTO_WALL, JSON.parse(this.wrapper.getAttribute('data-default-filters')));
        this.filterManager.prefillFromStorage(FilterName.PHOTO_WALL);
        redraw();

        this.wrapper.querySelectorAll('[data-dataTable-filter]').forEach(el => el.addEventListener('input', redraw));
        this.lightGallery.bindEvents();

        if (this.resetBtn) {
            this.resetBtn.addEventListener('click', e => {
                e.preventDefault();
                this.filterManager.resetAll();
                redraw();
            });
        }

        this.wrapper.querySelectorAll('[data-datatable-filter-clear]').forEach(btn => {
            btn.addEventListener('click', e => {
                e.preventDefault();
                const name = btn.getAttribute('data-datatable-filter-clear');
                this.filterManager.resetOne(name);
                redraw();
            });
        });
    }
}

;// ./public/js/features/maps/leaflet-map.js


class LeafletMap {
    constructor(mapNode, data) {
        this.mapNode = mapNode;
        this.data = data;

        this.map = L.map(mapNode, {
            scrollWheelZoom: data.scrollWheelZoom || false,
            minZoom: data.minZoom,
            maxZoom: data.maxZoom,
            zoomSnap: .5,
            zoomDelta: .5,
        });

        if (data.tileLayer) {
            L.tileLayer(data.tileLayer).addTo(this.map);
        }
    }

    async addRoutes() {
        const featureGroup = L.featureGroup();
        const polylines = await fetchJson(this.data.polylineUrl);

        for (const coordinates of polylines) {
            L.polyline(coordinates, {
                color: '#fc6719',
                weight: 2,
                opacity: 0.9,
                lineJoin: 'round'
            }).addTo(featureGroup);

            if (this.data.showStartMarker) {
                this.addCircleMarker(coordinates[0], '#3ba272').addTo(featureGroup);
            }
            if (this.data.showEndMarker) {
                this.addCircleMarker(coordinates.at(-1), '#BD2D22').addTo(featureGroup);
            }
        }

        if (this.data.imageOverlay) {
            L.imageOverlay(this.data.imageOverlay, this.data.bounds, {
                attribution: ' <a href="https://zwift.com" rel="noreferrer noopener">Zwift</a>',
            }).addTo(this.map);
            this.map.setMaxBounds(this.data.bounds);
        }

        featureGroup.addTo(this.map);
        this.map.fitBounds(featureGroup.getBounds(), {maxZoom: this.data.maxZoom});
    }

    addGpxControl() {
        if (!this.data.gpxLink) {
            return;
        }

        L.control.downloadGpx({gpxLink: this.data.gpxLink}).addTo(this.map);
    }

    async connectToEChart() {
        if (!this.mapNode.hasAttribute('data-leaflet-echart-connect')) {
            return;
        }

        const eChartNode = document.querySelector('div[data-echarts-options][data-leaflet-echart-connect]');
        if (!eChartNode) {
            return;
        }

        const coordinatesUrl = eChartNode.getAttribute('data-leaflet-echart-connect');
        if (!coordinatesUrl) {
            return;
        }

        try {
            const coordinateMap = await fetchJson(coordinatesUrl);
            const marker = this.addCircleMarker([0, 0], '#F26722', {radius: 6, opacity: 0}).addTo(this.map);
            const chart = echarts.getInstanceByDom(eChartNode);
            const initialZoom = this.map.getZoom();

            chart.on('updateAxisPointer', (event) => {
                if (!event.dataIndex || !event.dataIndex in coordinateMap) {
                    marker.setStyle({opacity: 0, fillOpacity: 0});
                    return;
                }

                const coordinate = coordinateMap[event.dataIndex];
                marker.setLatLng(coordinate);
                marker.setStyle({opacity: 1, fillOpacity: 1});

                const shouldPan = this.map.getZoom() > initialZoom || !this.map.getBounds().contains(coordinate);
                if (shouldPan) {
                    this.map.panTo(coordinate);
                }
            });
        } catch (error) {
            console.error('Failed to load coordinate map:', error);
        }
    }

    addCircleMarker(latLng, fillColor, {radius = 8, opacity = 1} = {}) {
        return L.circleMarker(latLng, {
            radius,
            color: '#303030',
            fillColor,
            fillOpacity: opacity,
            opacity,
        });
    }

}

;// ./public/js/features/maps/map-manager.js


class MapManager {
    init(rootNode) {
        rootNode.querySelectorAll('[data-leaflet]').forEach(async mapNode => {
            const data = JSON.parse(mapNode.getAttribute('data-leaflet'));
            const leafletMap = new LeafletMap(mapNode, data);

            await leafletMap.addRoutes();
            leafletMap.addGpxControl();
            leafletMap.connectToEChart();
        });
    }
}

;// ./public/js/components/tabs.js


class TabsManager {
    init(rootNode) {
        rootNode.querySelectorAll('[data-tabs]').forEach(($triggerEl) => {
            const tabItems = [];
            let defaultTabId = null;

            $triggerEl
                .querySelectorAll('[role="tab"]')
                .forEach(function ($triggerEl) {
                    const dataTabsTarget = $triggerEl.getAttribute('data-tabs-target');
                    tabItems.push({
                        id: dataTabsTarget,
                        triggerEl: $triggerEl,
                        targetEl: document.querySelector(dataTabsTarget),
                    });
                    if ($triggerEl.hasAttribute('data-tab-default')) {
                        defaultTabId = dataTabsTarget;
                    }
                });

            new Tabs($triggerEl, tabItems, {
                defaultTabId: defaultTabId,
                activeClasses: $triggerEl.getAttribute('data-tabs-active-classes') || 'text-strava-orange border-strava-orange hover:text-gray-600 hover:border-gray-300',
                inactiveClasses: $triggerEl.getAttribute('data-tabs-inactive-classes') || 'text-gray-500 hover:text-gray-600 border-gray-100 hover:border-gray-300',
                onShow: (tabs, activeTab) => {
                    const activeTabId = activeTab.id.replace('#', '');
                    // Trigger a chart resize to make sure charts are rendered and displayed.
                    eventBus.emit(Events.TAB_CHANGED, {activeTabId});
                },
            });
        });
    }
}

;// ./public/libraries/lazyload.min.js
/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/vanilla-lazyload@19.0.3/dist/esm/lazyload.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const e="undefined"!=typeof window,t=e&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),a=e&&window.devicePixelRatio>1,s={elements_selector:".lazy",container:t||e?document:null,threshold:300,thresholds:null,data_src:"src",data_srcset:"srcset",data_sizes:"sizes",data_bg:"bg",data_bg_hidpi:"bg-hidpi",data_bg_multi:"bg-multi",data_bg_multi_hidpi:"bg-multi-hidpi",data_bg_set:"bg-set",data_poster:"poster",class_applied:"applied",class_loading:"loading",class_loaded:"loaded",class_error:"error",class_entered:"entered",class_exited:"exited",unobserve_completed:!0,unobserve_entered:!1,cancel_on_exit:!0,callback_enter:null,callback_exit:null,callback_applied:null,callback_loading:null,callback_loaded:null,callback_error:null,callback_finish:null,callback_cancel:null,use_native:!1,restore_on_error:!1},n=e=>Object.assign({},s,e),l=function(e,t){let a;const s="LazyLoad::Initialized",n=new e(t);try{a=new CustomEvent(s,{detail:{instance:n}})}catch(e){a=document.createEvent("CustomEvent"),a.initCustomEvent(s,!1,!1,{instance:n})}window.dispatchEvent(a)},o="src",r="srcset",i="sizes",c="poster",d="llOriginalAttrs",_="data",u="loading",g="loaded",b="applied",m="error",h="native",p="data-",v="ll-status",f=(e,t)=>e.getAttribute(p+t),E=e=>f(e,v),I=(e,t)=>((e,t,a)=>{const s=p+t;null!==a?e.setAttribute(s,a):e.removeAttribute(s)})(e,v,t),k=e=>I(e,null),A=e=>null===E(e),y=e=>E(e)===h,w=[u,g,b,m],lazyload_min_L=(e,t,a,s)=>{e&&"function"==typeof e&&(void 0===s?void 0===a?e(t):e(t,a):e(t,a,s))},C=(t,a)=>{e&&""!==a&&t.classList.add(a)},O=(t,a)=>{e&&""!==a&&t.classList.remove(a)},x=e=>e.llTempImage,M=(e,t)=>{if(!t)return;const a=t._observer;a&&a.unobserve(e)},N=(e,t)=>{e&&(e.loadingCount+=t)},z=(e,t)=>{e&&(e.toLoadCount=t)},R=e=>{let t=[];for(let a,s=0;a=e.children[s];s+=1)"SOURCE"===a.tagName&&t.push(a);return t},T=(e,t)=>{const a=e.parentNode;a&&"PICTURE"===a.tagName&&R(a).forEach(t)},G=(e,t)=>{R(e).forEach(t)},D=[o],H=[o,c],V=[o,r,i],F=[_],j=e=>!!e[d],B=e=>e[d],J=e=>delete e[d],S=(e,t)=>{if(j(e))return;const a={};t.forEach((t=>{a[t]=e.getAttribute(t)})),e[d]=a},$=(e,t)=>{if(!j(e))return;const a=B(e);t.forEach((t=>{((e,t,a)=>{a?e.setAttribute(t,a):e.removeAttribute(t)})(e,t,a[t])}))},P=(e,t,a)=>{C(e,t.class_applied),I(e,b),a&&(t.unobserve_completed&&M(e,t),lazyload_min_L(t.callback_applied,e,a))},U=(e,t,a)=>{C(e,t.class_loading),I(e,u),a&&(N(a,1),lazyload_min_L(t.callback_loading,e,a))},q=(e,t,a)=>{a&&e.setAttribute(t,a)},K=(e,t)=>{q(e,i,f(e,t.data_sizes)),q(e,r,f(e,t.data_srcset)),q(e,o,f(e,t.data_src))},Q={IMG:(e,t)=>{T(e,(e=>{S(e,V),K(e,t)})),S(e,V),K(e,t)},IFRAME:(e,t)=>{S(e,D),q(e,o,f(e,t.data_src))},VIDEO:(e,t)=>{G(e,(e=>{S(e,D),q(e,o,f(e,t.data_src))})),S(e,H),q(e,c,f(e,t.data_poster)),q(e,o,f(e,t.data_src)),e.load()},OBJECT:(e,t)=>{S(e,F),q(e,_,f(e,t.data_src))}},W=["IMG","IFRAME","VIDEO","OBJECT"],X=(e,t)=>{!t||(e=>e.loadingCount>0)(t)||(e=>e.toLoadCount>0)(t)||lazyload_min_L(e.callback_finish,t)},Y=(e,t,a)=>{e.addEventListener(t,a),e.llEvLisnrs[t]=a},Z=(e,t,a)=>{e.removeEventListener(t,a)},ee=e=>!!e.llEvLisnrs,te=e=>{if(!ee(e))return;const t=e.llEvLisnrs;for(let a in t){const s=t[a];Z(e,a,s)}delete e.llEvLisnrs},ae=(e,t,a)=>{(e=>{delete e.llTempImage})(e),N(a,-1),(e=>{e&&(e.toLoadCount-=1)})(a),O(e,t.class_loading),t.unobserve_completed&&M(e,a)},se=(e,t,a)=>{const s=x(e)||e;ee(s)||((e,t,a)=>{ee(e)||(e.llEvLisnrs={});const s="VIDEO"===e.tagName?"loadeddata":"load";Y(e,s,t),Y(e,"error",a)})(s,(n=>{((e,t,a,s)=>{const n=y(t);ae(t,a,s),C(t,a.class_loaded),I(t,g),lazyload_min_L(a.callback_loaded,t,s),n||X(a,s)})(0,e,t,a),te(s)}),(n=>{((e,t,a,s)=>{const n=y(t);ae(t,a,s),C(t,a.class_error),I(t,m),lazyload_min_L(a.callback_error,t,s),a.restore_on_error&&$(t,V),n||X(a,s)})(0,e,t,a),te(s)}))},ne=(e,t,s)=>{(e=>W.indexOf(e.tagName)>-1)(e)?((e,t,a)=>{se(e,t,a),((e,t,a)=>{const s=Q[e.tagName];s&&(s(e,t),U(e,t,a))})(e,t,a)})(e,t,s):((e,t,s)=>{(e=>{e.llTempImage=document.createElement("IMG")})(e),se(e,t,s),(e=>{j(e)||(e[d]={backgroundImage:e.style.backgroundImage})})(e),((e,t,s)=>{const n=f(e,t.data_bg),l=f(e,t.data_bg_hidpi),r=a&&l?l:n;r&&(e.style.backgroundImage=`url("${r}")`,x(e).setAttribute(o,r),U(e,t,s))})(e,t,s),((e,t,s)=>{const n=f(e,t.data_bg_multi),l=f(e,t.data_bg_multi_hidpi),o=a&&l?l:n;o&&(e.style.backgroundImage=o,P(e,t,s))})(e,t,s),((e,t,a)=>{const s=f(e,t.data_bg_set);if(!s)return;const n=s.split("|");let l=n.map((e=>`image-set(${e})`));e.style.backgroundImage=l.join(),""===e.style.backgroundImage&&(l=n.map((e=>`-webkit-image-set(${e})`)),e.style.backgroundImage=l.join()),P(e,t,a)})(e,t,s)})(e,t,s)},le=(e,t,a)=>{e.setAttribute("loading","lazy"),se(e,t,a),((e,t)=>{const a=Q[e.tagName];a&&a(e,t)})(e,t),I(e,h)},oe=e=>{e.removeAttribute(o),e.removeAttribute(r),e.removeAttribute(i)},re=e=>{T(e,(e=>{$(e,V)})),$(e,V)},ie={IMG:re,IFRAME:e=>{$(e,D)},VIDEO:e=>{G(e,(e=>{$(e,D)})),$(e,H),e.load()},OBJECT:e=>{$(e,F)}},ce=(e,t)=>{(e=>{const t=ie[e.tagName];t?t(e):(e=>{if(!j(e))return;const t=B(e);e.style.backgroundImage=t.backgroundImage})(e)})(e),((e,t)=>{A(e)||y(e)||(O(e,t.class_entered),O(e,t.class_exited),O(e,t.class_applied),O(e,t.class_loading),O(e,t.class_loaded),O(e,t.class_error))})(e,t),k(e),J(e)},de=(e,t,a,s)=>{a.cancel_on_exit&&(e=>E(e)===u)(e)&&"IMG"===e.tagName&&(te(e),(e=>{T(e,(e=>{oe(e)})),oe(e)})(e),re(e),O(e,a.class_loading),N(s,-1),k(e),lazyload_min_L(a.callback_cancel,e,t,s))},_e=(e,t,a,s)=>{const n=(e=>w.indexOf(E(e))>=0)(e);I(e,"entered"),C(e,a.class_entered),O(e,a.class_exited),((e,t,a)=>{t.unobserve_entered&&M(e,a)})(e,a,s),lazyload_min_L(a.callback_enter,e,t,s),n||ne(e,a,s)},ue=["IMG","IFRAME","VIDEO"],ge=e=>e.use_native&&"loading"in HTMLImageElement.prototype,be=(e,t)=>{ge(e)||(t._observer=new IntersectionObserver((a=>{((e,t,a)=>{e.forEach((e=>(e=>e.isIntersecting||e.intersectionRatio>0)(e)?_e(e.target,e,t,a):((e,t,a,s)=>{A(e)||(C(e,a.class_exited),de(e,t,a,s),lazyload_min_L(a.callback_exit,e,t,s))})(e.target,e,t,a)))})(a,e,t)}),(e=>({root:e.container===document?null:e.container,rootMargin:e.thresholds||e.threshold+"px"}))(e)))},me=e=>Array.prototype.slice.call(e),he=e=>e.container.querySelectorAll(e.elements_selector),pe=e=>(e=>E(e)===m)(e),ve=(e,t)=>(e=>me(e).filter(A))(e||he(t)),fe=(e,t)=>{(e=>me(e).filter(pe))(he(e)).forEach((t=>{O(t,e.class_error),k(t)})),t.update()},Ee=function(t,a){const s=n(t);this._settings=s,this.loadingCount=0,be(s,this),((t,a)=>{e&&(a._onlineHandler=()=>{fe(t,a)},window.addEventListener("online",a._onlineHandler))})(s,this),this.update(a)};Ee.prototype={update:function(e){const a=this._settings,s=ve(e,a);z(this,s.length),t?this.loadAll(s):ge(a)?((e,t,a)=>{e.forEach((e=>{-1!==ue.indexOf(e.tagName)&&le(e,t,a)})),z(a,0)})(s,a,this):((e,t)=>{(e=>{e.disconnect()})(e),((e,t)=>{t.forEach((t=>{e.observe(t)}))})(e,t)})(this._observer,s)},destroy:function(){this._observer&&this._observer.disconnect(),(t=>{e&&window.removeEventListener("online",t._onlineHandler)})(this),he(this._settings).forEach((e=>{J(e)})),delete this._observer,delete this._settings,delete this._onlineHandler,delete this.loadingCount,delete this.toLoadCount},loadAll:function(e){const t=this._settings;ve(e,t).forEach((e=>{M(e,this),ne(e,t,this)}))},restoreAll:function(){const e=this._settings;he(e).forEach((t=>{ce(t,e)}))}},Ee.load=(e,t)=>{const a=n(t);ne(e,a)},Ee.resetStatus=e=>{k(e)},e&&((e,t)=>{if(t)if(t.length)for(let a,s=0;a=t[s];s+=1)l(e,a);else l(e,t)})(Ee,window.lazyLoadOptions);
//# sourceMappingURL=/sm/b5b7e51546921ac9618010f8961abe225b08661affff4158a39d72b3398549d9.map
// EXTERNAL MODULE: ./public/libraries/clusterize/clusterize.min.js
var clusterize_min = __webpack_require__(816);
var clusterize_min_default = /*#__PURE__*/__webpack_require__.n(clusterize_min);
;// ./public/js/features/data-table/summable-calculator.js


class SummableCalculator {
    static calculate(rows) {
        return rows
            .filter(r => r.active)
            .reduce((acc, r) => {
                Object.entries(r.summables).forEach(([k, v]) => acc[k] = (acc[k] || 0) + v);
                return acc;
            }, {});
    }

    static render(wrapper, rows) {
        const sums = this.calculate(rows);
        wrapper.querySelectorAll('[data-dataTable-summable]').forEach(node => {
            const key = node.getAttribute('data-dataTable-summable');
            node.innerHTML = sums[key] !== undefined ? numberFormat(sums[key], 0, ',', ' ') : 0;
        });
    }
}

;// ./public/js/features/data-table/cluster-renderer.js




class ClusterRenderer {
    constructor(wrapper, tbody, scrollElem) {
        this.wrapper = wrapper;
        this.tbody = tbody;
        this.scrollElem = scrollElem;
        this.cluster = null;
    }

    init(dataRows) {
        this.cluster = new (clusterize_min_default())({
            rows: dataRows.filter(r => r.active).map(r => r.markup),
            scrollElem: this.scrollElem,
            contentElem: this.tbody,
            no_data_class: 'clusterize-data-empty',
            no_data_text: 'No data found',
            callbacks: {
                clusterChanged: () => {
                    SummableCalculator.render(this.wrapper, dataRows);

                    const resultCount = this.wrapper.querySelector('[data-dataTable-result-count]');
                    if (resultCount) resultCount.innerText = dataRows.filter(r => r.active).length;

                    eventBus.emit(Events.DATA_TABLE_CLUSTER_CHANGED, {node: this.wrapper});
                }
            }
        });
    }

    update(dataRows) {
        if (!this.cluster) return;
        this.cluster.update(dataRows.filter(r => r.active).map(r => r.markup));
        this.scrollElem.scrollTop = 0;
    }
}

;// ./public/js/features/data-table/sorter.js
class Sorter {
    constructor(columns) {
        this.columns = columns; // NodeList of <th>
        this.sortAsc = false;
        this.sortOnPrevious = null;
    }

    attachListeners(dataRows, cluster, scrollElem) {
        this.columns.forEach(th => th.addEventListener('click', () => {
            const sortOn = th.getAttribute('data-dataTable-sort');
            if (sortOn === this.sortOnPrevious) this.sortAsc = !this.sortAsc;
            else this.sortAsc = true;
            this.sortOnPrevious = sortOn;

            this.columns.forEach(c => c.querySelector('.sorting-icon')?.setAttribute('aria-sort', 'none'));
            th.querySelector('.sorting-icon')?.setAttribute('aria-sort', this.sortAsc ? 'ascending' : 'descending');

            dataRows.sort((a, b) => {
                const aVal = a.sort[sortOn], bVal = b.sort[sortOn];
                if (aVal === undefined) return 1;
                if (bVal === undefined) return -1;
                if (aVal < bVal) return this.sortAsc ? -1 : 1;
                if (aVal > bVal) return this.sortAsc ? 1 : -1;
                return 0;
            });

            cluster.update(dataRows.filter(r => r.active).map(r => r.markup));
            scrollElem.scrollTop = 0;
        }));
    }
}

;// ./public/js/features/data-table/data-table-manager.js





class DataTableManager {

    init(rootNode) {
        rootNode.querySelectorAll('div[data-dataTable-settings]').forEach((wrapper) => {
            const table = wrapper.querySelector('table');
            const tbody = table?.querySelector('tbody');
            const scrollElem = wrapper.querySelector('.scroll-area');
            const searchInput = wrapper.querySelector('input[type="search"]');
            const resetBtn = wrapper.querySelector('[data-dataTable-reset]');
            const settings = JSON.parse(wrapper.getAttribute('data-dataTable-settings'));

            const filterManager = new FilterManager(wrapper);
            const clusterRenderer = new ClusterRenderer(wrapper, tbody, scrollElem);
            const sorter = new Sorter(wrapper.querySelectorAll('thead th[data-dataTable-sort]'));

            if (!table || !tbody || !searchInput) return;

            fetch(settings.url, {cache: 'no-store'}).then(async (response) => {
                const dataRows = await response.json();

                // Init cluster.
                clusterRenderer.init(dataRows);

                const updateState = (updateStorage = true) => {
                    const search = searchInput.value.trim();
                    const activeFilters = filterManager.getActiveFilters();

                    filterManager.updateDropdownState(activeFilters);
                    if (updateStorage) {
                        filterManager.updateStorage(settings.name, activeFilters);
                    }
                    const rows = filterManager.applyFiltersToRows(dataRows, search);
                    clusterRenderer.update(rows);
                    resetBtn.classList.toggle('hidden', !(Object.keys(activeFilters).length > 0 || search.length > 0));
                };

                // Prefill filters.
                filterManager.prefillFromStorage(settings.name);
                updateState(false);

                // Attach events.
                searchInput.addEventListener('input', debounce(updateState));
                wrapper.querySelectorAll('[data-dataTable-filter]').forEach(el => el.addEventListener('input', updateState));
                sorter.attachListeners(dataRows, clusterRenderer.cluster, scrollElem);

                if (resetBtn) {
                    resetBtn.addEventListener('click', e => {
                        e.preventDefault();
                        searchInput.value = '';
                        filterManager.resetAll(settings.name);
                        updateState();
                    });
                }

                wrapper.querySelectorAll('[data-datatable-filter-clear]').forEach(btn => {
                    btn.addEventListener('click', e => {
                        e.preventDefault();
                        const name = btn.getAttribute('data-datatable-filter-clear');
                        filterManager.resetOne(name);
                        updateState();
                    });
                });
            });
        });
    }
}

;// ./public/js/components/fullscreen.js


class FullscreenManager {
    init(rootNode) {
        rootNode.querySelectorAll('[data-fullscreen-trigger]').forEach((el) => {
            el.addEventListener('click', (e) => {
                e.preventDefault();

                if (document.fullscreenElement) {
                    return;
                }

                const fullScreenContent = el.closest('[data-fullscreen-content]');
                fullScreenContent.requestFullscreen().then(() => {
                    eventBus.emit(Events.FULLSCREEN_ENABLED);
                });

                fullScreenContent.addEventListener('fullscreenchange', () => {
                    fullScreenContent.toggleAttribute('data-fullscreen-enabled', Boolean(document.fullscreenElement))
                });

            });
        });
    }
}
;// ./public/libraries/turf.js
const earthRadius = 63710088e-1;
const factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
};

const __defProp = Object.defineProperty;
const __defProps = Object.defineProperties;
const __getOwnPropDescs = Object.getOwnPropertyDescriptors;
const __getOwnPropSymbols = Object.getOwnPropertySymbols;
const __hasOwnProp = Object.prototype.hasOwnProperty;
const __propIsEnum = Object.prototype.propertyIsEnumerable;
const __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
const __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
        }
    return a;
};
const __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

function bearing(start, end, options = {}) {
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    const coordinates1 = getCoord(start);
    const coordinates2 = getCoord(end);
    const lon1 = degreesToRadians(coordinates1[0]);
    const lon2 = degreesToRadians(coordinates2[0]);
    const lat1 = degreesToRadians(coordinates1[1]);
    const lat2 = degreesToRadians(coordinates2[1]);
    const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
    let bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}

function distance(from, to, options = {}) {
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return radiansToLength(
        2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
        options.units
    );
}

function feature(geom, properties, options = {}) {
    const feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
function point(coordinates, properties, options = {}) {
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    const geom = {
        type: "Point",
        coordinates
    };
    return feature(geom, properties, options);
}
function lineString(coordinates, properties, options = {}) {
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    const geom = {
        type: "LineString",
        coordinates
    };
    return feature(geom, properties, options);
}
function radiansToLength(radians, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
function lengthToRadians(distance, units = "kilometers") {
    const factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
function radiansToDegrees(radians) {
    const normalisedRadians = radians % (2 * Math.PI);
    return normalisedRadians * 180 / Math.PI;
}
function degreesToRadians(degrees) {
    const normalisedDegrees = degrees % 360;
    return normalisedDegrees * Math.PI / 180;
}
function convertLength(length, originalUnit = "kilometers", finalUnit = "kilometers") {
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}

function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return [...coord.geometry.coordinates];
        }
        if (coord.type === "Point") {
            return [...coord.coordinates];
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return [...coord];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error(
        "coords must be GeoJSON Feature, Geometry Object or an Array"
    );
}
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error(
            "Invalid input to " + name + ", Feature with geometry required"
        );
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error(
            "Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type
        );
    }
}

function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
                case null:
                    break;
                case "Point":
                    if (callback(
                        coords,
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                    ) === false)
                        return false;
                    coordIndex++;
                    multiFeatureIndex++;
                    break;
                case "LineString":
                case "MultiPoint":
                    for (j = 0; j < coords.length; j++) {
                        if (callback(
                            coords[j],
                            coordIndex,
                            featureIndex,
                            multiFeatureIndex,
                            geometryIndex
                        ) === false)
                            return false;
                        coordIndex++;
                        if (geomType === "MultiPoint") multiFeatureIndex++;
                    }
                    if (geomType === "LineString") multiFeatureIndex++;
                    break;
                case "Polygon":
                case "MultiLineString":
                    for (j = 0; j < coords.length; j++) {
                        for (k = 0; k < coords[j].length - wrapShrink; k++) {
                            if (callback(
                                coords[j][k],
                                coordIndex,
                                featureIndex,
                                multiFeatureIndex,
                                geometryIndex
                            ) === false)
                                return false;
                            coordIndex++;
                        }
                        if (geomType === "MultiLineString") multiFeatureIndex++;
                        if (geomType === "Polygon") geometryIndex++;
                    }
                    if (geomType === "Polygon") multiFeatureIndex++;
                    break;
                case "MultiPolygon":
                    for (j = 0; j < coords.length; j++) {
                        geometryIndex = 0;
                        for (k = 0; k < coords[j].length; k++) {
                            for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                                if (callback(
                                    coords[j][k][l],
                                    coordIndex,
                                    featureIndex,
                                    multiFeatureIndex,
                                    geometryIndex
                                ) === false)
                                    return false;
                                coordIndex++;
                            }
                            geometryIndex++;
                        }
                        multiFeatureIndex++;
                    }
                    break;
                case "GeometryCollection":
                    for (j = 0; j < geometry.geometries.length; j++)
                        if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                            return false;
                    break;
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
    }
}
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
        geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
        featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
        featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
        featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
        isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
                if (callback(
                    null,
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                ) === false)
                    return false;
                continue;
            }
            switch (geometry.type) {
                case "Point":
                case "LineString":
                case "MultiPoint":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon": {
                    if (callback(
                        geometry,
                        featureIndex,
                        featureProperties,
                        featureBBox,
                        featureId
                    ) === false)
                        return false;
                    break;
                }
                case "GeometryCollection": {
                    for (j = 0; j < geometry.geometries.length; j++) {
                        if (callback(
                            geometry.geometries[j],
                            featureIndex,
                            featureProperties,
                            featureBBox,
                            featureId
                        ) === false)
                            return false;
                    }
                    break;
                }
                default:
                    throw new Error("Unknown Geometry Type");
            }
        }
        featureIndex++;
    }
}
function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
        var type = geometry === null ? null : geometry.type;
        switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                if (callback(
                    feature(geometry, properties, { bbox, id }),
                    featureIndex,
                    0
                ) === false)
                    return false;
                return;
        }
        var geomType;
        switch (type) {
            case "MultiPoint":
                geomType = "Point";
                break;
            case "MultiLineString":
                geomType = "LineString";
                break;
            case "MultiPolygon":
                geomType = "Polygon";
                break;
        }
        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
                return false;
        }
    });
}
function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;
        if (!feature2.geometry) return;
        var type = feature2.geometry.type;
        if (type === "Point" || type === "MultiPoint") return;
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(
            feature2,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
                if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                    previousCoords = currentCoord;
                    previousFeatureIndex = featureIndex;
                    previousMultiIndex = multiPartIndexCoord;
                    prevGeomIndex = geometryIndex;
                    segmentIndex = 0;
                    return;
                }
                var currentSegment = lineString(
                    [previousCoords, currentCoord],
                    feature2.properties
                );
                if (callback(
                    currentSegment,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex,
                    segmentIndex
                ) === false)
                    return false;
                segmentIndex++;
                previousCoords = currentCoord;
            }
        ) === false)
            return false;
    });
}

function nearestPointOnLine(lines, pt, options = {}) {
    if (!lines || !pt) {
        throw new Error("lines and pt are required arguments");
    }
    const ptPos = getCoord(pt);
    let closestPt = point([Infinity, Infinity], {
        dist: Infinity,
        index: -1,
        multiFeatureIndex: -1,
        location: -1
    });
    let length = 0;
    flattenEach(
        lines,
        function(line, _featureIndex, multiFeatureIndex) {
            const coords = getCoords(line);
            for (let i = 0; i < coords.length - 1; i++) {
                const start = point(coords[i]);
                const startPos = getCoord(start);
                const stop = point(coords[i + 1]);
                const stopPos = getCoord(stop);
                const sectionLength = distance(start, stop, options);
                let intersectPos;
                let wasEnd;
                if (stopPos[0] === ptPos[0] && stopPos[1] === ptPos[1]) {
                    [intersectPos, wasEnd] = [stopPos, true];
                } else if (startPos[0] === ptPos[0] && startPos[1] === ptPos[1]) {
                    [intersectPos, wasEnd] = [startPos, false];
                } else {
                    [intersectPos, wasEnd] = nearestPointOnSegment(
                        startPos,
                        stopPos,
                        ptPos
                    );
                }
                const intersectPt = point(intersectPos, {
                    dist: distance(pt, intersectPos, options),
                    multiFeatureIndex,
                    location: length + distance(start, intersectPos, options)
                });
                if (intersectPt.properties.dist < closestPt.properties.dist) {
                    closestPt = __spreadProps(__spreadValues({}, intersectPt), {
                        properties: __spreadProps(__spreadValues({}, intersectPt.properties), {
                            // Legacy behaviour where index progresses to next segment # if we
                            // went with the end point this iteration.
                            index: wasEnd ? i + 1 : i
                        })
                    });
                }
                length += sectionLength;
            }
        }
    );
    return closestPt;
}

function cross(v1, v2) {
    const [v1x, v1y, v1z] = v1;
    const [v2x, v2y, v2z] = v2;
    return [v1y * v2z - v1z * v2y, v1z * v2x - v1x * v2z, v1x * v2y - v1y * v2x];
}
function magnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2) + Math.pow(v[2], 2));
}
function normalize(v) {
    const mag = magnitude(v);
    return [v[0] / mag, v[1] / mag, v[2] / mag];
}
function lngLatToVector(a) {
    const lat = degreesToRadians(a[1]);
    const lng = degreesToRadians(a[0]);
    return [
        Math.cos(lat) * Math.cos(lng),
        Math.cos(lat) * Math.sin(lng),
        Math.sin(lat)
    ];
}
function vectorToLngLat(v) {
    const [x, y, z] = v;
    const zClamp = Math.min(Math.max(z, -1), 1);
    const lat = radiansToDegrees(Math.asin(zClamp));
    const lng = radiansToDegrees(Math.atan2(y, x));
    return [lng, lat];
}
function nearestPointOnSegment(posA, posB, posC) {
    const A = lngLatToVector(posA);
    const B = lngLatToVector(posB);
    const C = lngLatToVector(posC);
    const segmentAxis = cross(A, B);
    if (segmentAxis[0] === 0 && segmentAxis[1] === 0 && segmentAxis[2] === 0) {
        if (dot(A, B) > 0) {
            return [[...posB], true];
        } else {
            return [[...posC], false];
        }
    }
    const targetAxis = cross(segmentAxis, C);
    if (targetAxis[0] === 0 && targetAxis[1] === 0 && targetAxis[2] === 0) {
        return [[...posB], true];
    }
    const intersectionAxis = cross(targetAxis, segmentAxis);
    const I1 = normalize(intersectionAxis);
    const I2 = [-I1[0], -I1[1], -I1[2]];
    const I = dot(C, I1) > dot(C, I2) ? I1 : I2;
    const segmentAxisNorm = normalize(segmentAxis);
    const cmpAI = dot(cross(A, I), segmentAxisNorm);
    const cmpIB = dot(cross(I, B), segmentAxisNorm);
    if (cmpAI >= 0 && cmpIB >= 0) {
        return [vectorToLngLat(I), false];
    }
    if (dot(A, C) > dot(B, C)) {
        return [[...posA], false];
    } else {
        return [[...posB], true];
    }
}

function pointToLineDistance(pt, line, options = {}) {
    var _a, _b;
    const method = (_a = options.method) != null ? _a : "geodesic";
    const units = (_b = options.units) != null ? _b : "kilometers";
    if (!pt) {
        throw new Error("pt is required");
    }
    if (Array.isArray(pt)) {
        pt = point(pt);
    } else if (pt.type === "Point") {
        pt = feature(pt);
    } else {
        featureOf(pt, "Point", "point");
    }
    if (!line) {
        throw new Error("line is required");
    }
    if (Array.isArray(line)) {
        line = lineString(line);
    } else if (line.type === "LineString") {
        line = feature(line);
    } else {
        featureOf(line, "LineString", "line");
    }
    let distance = Infinity;
    const p = pt.geometry.coordinates;
    segmentEach(line, (segment) => {
        if (segment) {
            const a = segment.geometry.coordinates[0];
            const b = segment.geometry.coordinates[1];
            const d = distanceToSegment(p, a, b, { method });
            if (d < distance) {
                distance = d;
            }
        }
    });
    return convertLength(distance, "degrees", units);
}
function distanceToSegment(p, a, b, options) {
    if (options.method === "geodesic") {
        const nearest = nearestPointOnLine(lineString([a, b]).geometry, p, {
            units: "degrees"
        });
        return nearest.properties.dist;
    }
    const v = [b[0] - a[0], b[1] - a[1]];
    const w = [p[0] - a[0], p[1] - a[1]];
    const c1 = dot(w, v);
    if (c1 <= 0) {
        return rhumbDistance(p, a, { units: "degrees" });
    }
    const c2 = dot(v, v);
    if (c2 <= c1) {
        return rhumbDistance(p, b, { units: "degrees" });
    }
    const b2 = c1 / c2;
    const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];
    return rhumbDistance(p, Pb, { units: "degrees" });
}
function dot(u, v) {
    return u[0] * v[0] + u[1] * v[1];
}
function rhumbDistance(from, to, options = {}) {
    const origin = getCoord(from);
    const destination = getCoord(to);
    destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;
    const distanceInMeters = calculateRhumbDistance(origin, destination);
    const distance = convertLength(distanceInMeters, "meters", options.units);
    return distance;
}
function calculateRhumbDistance(origin, destination, radius) {
    radius = radius === void 0 ? earthRadius : Number(radius);
    const R = radius;
    const phi1 = origin[1] * Math.PI / 180;
    const phi2 = destination[1] * Math.PI / 180;
    const DeltaPhi = phi2 - phi1;
    let DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;
    if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
    }
    const DeltaPsi = Math.log(
        Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4)
    );
    const q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const delta = Math.sqrt(
        DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda
    );
    const dist = delta * R;
    return dist;
}


;// ./public/js/features/heatmap/heatmap-drawer.js


class HeatmapDrawer {
    constructor(wrapper, config, modalManager) {
        this.wrapper = wrapper;
        this.config = config;
        this.modalManager = modalManager;
        this.placesControl = null;
        this.mainFeatureGroup = L.featureGroup();
        this.routePolylines = [];
        this.map = L.map(this.wrapper, {
            scrollWheelZoom: true,
            minZoom: 1,
            maxZoom: 21,
        });
        this.config.tileLayerUrls.forEach((tileLayerUrl) => {
            L.tileLayer(tileLayerUrl).addTo(this.map);
        });
        this.defaultPolylineStyle = {
            color: this.config.polylineColor,
            weight: 1.5,
            opacity: 0.5,
            smoothFactor: 1,
            overrideExisting: true,
            detectColors: true,
        };
        this.inactivePolylineStyle = {
            weight: 0,
            opacity: 0,
        }
        this.map.on("click", (e) => this._handleMapClick(e));
        this.map.on("popupclose", () => this._resetRouteStyles());
        this.map.on("popupopen", (e) => this._handlePopupOpen(e));
    }

    _resetRouteStyles() {
        this.routePolylines.forEach(entry => {
            entry.polyline.setStyle(this.defaultPolylineStyle);
        });
    }

    _handlePopupOpen(e) {
        const container = e.popup.getElement();
        if (!container) return;

        container.querySelectorAll('a[data-model-content-url]').forEach(node => {
            node.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.modalManager.open(node.getAttribute('data-model-content-url'));
            });
        });
    };

    _handleMapClick(e) {
        const clickPoint = point([e.latlng.lng, e.latlng.lat]);
        const NEARBY_DISTANCE_IN_METERS = 100;
        this._resetRouteStyles();

        const nearby = [];
        const notNearby = [];

        this.routePolylines.forEach((entry) => {
            const line = lineString(entry.coordinates.map(ll => [ll[1], ll[0]]));
            const dist = pointToLineDistance(clickPoint, line, {units: "meters"});

            if (dist <= NEARBY_DISTANCE_IN_METERS) {
                nearby.push(entry);
            } else {
                notNearby.push(entry);
            }
        });

        if (nearby.length === 0) {
            return;
        }

        notNearby.forEach(entry => {
            entry.polyline.setStyle(this.inactivePolylineStyle);
        });

        const html = `
            <div class="m-4 text-sm max-h-50 overflow-y-auto no-dark">
                <div class="font-medium">${nearby.length} nearby route(s):</div>
                 <ul class="divide-default divide-y divide-gray-200">
                    ${nearby.map(entry => `
                     <li class="py-2">
                      <a href="#" title="${entry.route.name}" class="block truncate font-medium text-blue-600 hover:underline" 
                        data-model-content-url="${entry.route.activityUrl}">
                        ${entry.route.name}
                      </a>
                      <div class="flex items-center justify-between text-xs text-gray-500">
                        <div>${entry.route.startDate}</div>
                        <div>${entry.route.distance}</div>
                      </div>
                    </li>`).join("")}
                </ul>
            </div>`;

        L.popup(e.latlng,
            {
                content: html,
                maxWidth: 300,
                minWidth: 300
            }).openOn(this.map);
    }

    redraw(routes) {
        routes = routes.filter((route) => route.active);
        this.mainFeatureGroup.clearLayers();
        this.routePolylines = [];
        if (this.placesControl) {
            this.map.removeControl(this.placesControl);
        }

        const determineMostActiveState = (routes) => {
            const stateCounts = routes.reduce((counts, route) => {
                const state = route.startLocation.state;
                if (state) counts[state] = (counts[state] || 0) + 1;
                return counts;
            }, {});

            const mostActiveState = Object.keys(stateCounts).reduce((a, b) => stateCounts[a] > stateCounts[b] ? a : b, '');
            return mostActiveState ? mostActiveState : null;
        };

        const places = [];
        const countryFeatureGroups = new Map();
        const fitMapBoundsFeatureGroup = L.featureGroup();
        const mostActiveState = determineMostActiveState(routes);

        routes.forEach(route => {
            const {countryCode, state} = route.startLocation;

            if (!countryFeatureGroups.has(countryCode)) {
                countryFeatureGroups.set(countryCode, L.featureGroup());
            }

            const polyline = L.polyline(
                route.coordinates,
                this.defaultPolylineStyle
            ).addTo(countryFeatureGroups.get(countryCode));

            this.routePolylines.push({
                route: route,
                polyline: polyline,
                coordinates: route.coordinates
            });

            if (mostActiveState === state) {
                L.polyline(route.coordinates).addTo(fitMapBoundsFeatureGroup);
            }
        });

        countryFeatureGroups.forEach((featureGroup, countryCode) => {
            featureGroup.addTo(this.mainFeatureGroup);
            places.push({
                countryCode: countryCode,
                bounds: featureGroup.getBounds()
            });
        });
        this.mainFeatureGroup.addTo(this.map);

        this.placesControl = L.control.flyToPlaces({places});
        this.placesControl.addTo(this.map);

        if (fitMapBoundsFeatureGroup.getBounds().isValid()) {
            this.map.fitBounds(fitMapBoundsFeatureGroup.getBounds());
        }
    }
}

;// ./public/js/features/heatmap/heatmap.js





class Heatmap {
    constructor(wrapper, modalManager) {
        this.wrapper = wrapper;
        this.heatmap = wrapper.querySelector('[data-leaflet-routes]');
        this.resetBtn = wrapper.querySelector('[data-dataTable-reset]');
        this.config = JSON.parse(this.heatmap.getAttribute('data-heatmap-config'));

        this.filterManager = new FilterManager(wrapper);
        this.drawer = new HeatmapDrawer(this.heatmap, this.config, modalManager);
    }

    async render() {
        const apiUrl = this.heatmap.getAttribute('data-leaflet-routes');
        const allRoutes = await fetchJson(apiUrl);

        const redraw = (updateStorage = true) => {
            const activeFilters = this.filterManager.getActiveFilters();
            this.filterManager.updateDropdownState(activeFilters);
            if(updateStorage){
                this.filterManager.updateStorage(FilterName.HEATMAP, activeFilters);
            }

            const routes = this.filterManager.applyFiltersToRows(allRoutes);
            this.drawer.redraw(routes);

            this.resetBtn.classList.toggle('hidden', !(Object.keys(activeFilters).length > 0));
            const resultCount = this.wrapper.querySelector('[data-dataTable-result-count]');
            if (resultCount) resultCount.innerText = routes.filter((route) => route.active).length;
        };

        this.filterManager.prefillFromStorage(FilterName.HEATMAP);
        redraw(false);

        this.wrapper.querySelectorAll('[data-dataTable-filter]').forEach(el => el.addEventListener('input', redraw));

        if (this.resetBtn) {
            this.resetBtn.addEventListener('click', e => {
                e.preventDefault();
                this.filterManager.resetAll();
                redraw();
            });
        }

        this.wrapper.querySelectorAll('[data-datatable-filter-clear]').forEach(btn => {
            btn.addEventListener('click', e => {
                e.preventDefault();
                const name = btn.getAttribute('data-datatable-filter-clear');
                this.filterManager.resetOne(name);
                redraw();
            });
        });
    };

}

;// ./public/js/components/dark-mode.js


class DarkModeManager {
    constructor() {
        this.storageKey = 'theme';
        this.$toggleButton = document.querySelector('.dark-mode-toggle input');
        this.$themeElement = document.documentElement;
        this.dataAttributeName = 'data-theme';
    }

    attachEventListeners() {
        this.$toggleButton.checked = this.isDarkModeEnabled();
        this.$toggleButton.addEventListener('change', () => {
            this.setDark(!this.isDarkModeEnabled());
        });
    }

    isDarkModeEnabled() {
        return this.$themeElement.hasAttribute(this.dataAttributeName)
            && this.$themeElement.getAttribute(this.dataAttributeName) === 'dark';
    }

    setDark(enabled) {
        const theme = enabled ? 'dark' : 'light';
        localStorage.setItem(this.storageKey, theme);
        this.$themeElement.setAttribute(this.dataAttributeName, theme);

        this.$toggleButton.checked = enabled;

        eventBus.emit(Events.DARK_MODE_TOGGLED, {darkModeEnabled: enabled});
    }
}

;// ./public/js/app.js
















const $main = document.querySelector("main");

// Boot router.
const router = new Router($main);
router.boot();

const sidebar = new Sidebar();
const modalManager = new ModalManager(router);
const chartManager = new ChartManager(router, modalManager);
const mapManager = new MapManager();
const tabsManager = new TabsManager();
const dataTableManager = new DataTableManager();
const fullscreenManager = new FullscreenManager();
const darkModeManager = new DarkModeManager();
const lazyLoad = new Ee({
    thresholds: "50px",
    callback_error: (img) => {
        img.setAttribute("src", window.statisticsForStrava.placeholderBrokenImage);
    }
});

const initElements = (rootNode) => {
    lazyLoad.update();

    tabsManager.init(rootNode);
    initPopovers();
    initTooltips();
    initDropdowns();
    initAccordions();

    modalManager.init(rootNode);
    dataTableManager.init(rootNode);
    chartManager.init(rootNode, darkModeManager.isDarkModeEnabled());
    mapManager.init(rootNode);
    fullscreenManager.init(rootNode);
}

sidebar.init();
darkModeManager.attachEventListeners();

eventBus.on(Events.DARK_MODE_TOGGLED, ({darkModeEnabled}) => {
    chartManager.toggleDarkTheme(darkModeEnabled);
});
eventBus.on(Events.FULLSCREEN_ENABLED, () => {
    chartManager.resizeAll();
});
eventBus.on(Events.TAB_CHANGED, ({activeTabId}) => {
    chartManager.resizeInTab(activeTabId);
});

eventBus.on(Events.PAGE_LOADED, async ({page, modalId}) => {
    modalManager.close();

    chartManager.reset();
    initElements(document);

    if (modalId) {
        modalManager.open(modalId);
    }

    if (page === 'heatmap') {
        const $heatmapWrapper = document.querySelector('.heatmap-wrapper');
        await new Heatmap($heatmapWrapper, modalManager).render();
    }
    if (page === 'photos') {
        const $photoWallWrapper = document.querySelector('.photo-wall-wrapper');
        await new PhotoWall($photoWallWrapper).render();
    }
});
eventBus.on(Events.NAVIGATION_CLICKED, ({link}) => {
    if (!link || !link.hasAttribute('data-filters')) {
        return;
    }
    const filters = JSON.parse(link.getAttribute('data-filters'));
    Object.entries(filters).forEach(([tableName, tableFilters]) => {
        FilterStorage.set(tableName, tableFilters);
    });
});
eventBus.on(Events.MODAL_LOADED, async ({node, modalName}) => {
    initElements(node);

    if (modalName === 'ai-chat') {
        const {default: Chat} = await __webpack_require__.e(/* import() | chat */ 377).then(__webpack_require__.bind(__webpack_require__, 625));
        new Chat(node).render();
    }
});
eventBus.on(Events.DATA_TABLE_CLUSTER_CHANGED, ({node}) => {
    modalManager.init(node);
});
window.addEventListener('resize', function () {
    chartManager.resizeAll();
});
eventBus.on(Events.SIDEBAR_RESIZED, () => {
    chartManager.resizeAll();
});

const $modalAIChat = document.querySelector('a[data-modal-custom-ai]');
if ($modalAIChat) {
    $modalAIChat.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const modalId = $modalAIChat.getAttribute('data-modal-custom-ai');
        modalManager.open(modalId);
        router.pushCurrentRouteToHistoryState(modalId);
    });
}

(async () => {
    await updateGithubLatestRelease();
})();

})();

/******/ })()
;